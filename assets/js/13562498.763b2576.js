"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[6641],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>y});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),m=s(n),d=i,y=m["".concat(o,".").concat(d)]||m[d]||c[d]||r;return n?a.createElement(y,l(l({ref:t},u),{},{components:n})):a.createElement(y,l({ref:t},u))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p[m]="string"==typeof e?e:i,l[1]=p;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3558:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>p,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:2},l="Types",p={unversionedId:"onchain/Types",id:"onchain/Types",title:"Types",description:"As we saw in Concepts plu-ts is an eDSL embedded in Typescript, as such we have two type systems; the Typescript one and the plu-ts one",source:"@site/docs/onchain/Types.mdx",sourceDirName:"onchain",slug:"/onchain/Types",permalink:"/docs/onchain/Types",draft:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts/tree/main/packages/create-docusaurus/templates/shared/docs/onchain/Types.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Concepts",permalink:"/docs/onchain/Concepts"},next:{title:"Values",permalink:"/docs/category/values"}},o={},s=[{value:"Typescript Types",id:"typescript-types",level:2},{value:"<code>plu-ts</code> Types",id:"plu-ts-types",level:2},{value:"<code>plu-ts</code> generics",id:"plu-ts-generics",level:2}],u={toc:s},m="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"types"},"Types"),(0,i.kt)("p",null,"As we saw in ",(0,i.kt)("a",{parentName:"p",href:"./Concepts"},"Concepts")," ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," is an eDSL embedded in Typescript, as such we have two type systems; the Typescript one and the ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," one "),(0,i.kt)("h2",{id:"typescript-types"},"Typescript Types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Term")," is a Typescript type defined in ",(0,i.kt)("inlineCode",{parentName:"li"},"plu-ts"),". "),(0,i.kt)("li",{parentName:"ul"},"Every value in ",(0,i.kt)("inlineCode",{parentName:"li"},"plu-ts")," is a ",(0,i.kt)("inlineCode",{parentName:"li"},"Term"),". In Typescript, we say each value ",(0,i.kt)("em",{parentName:"li"},"extends"),' Term (in the same way that "Dog" extends "Mammal").'),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"Term")," also keeps track of the type of the value it holds. ")),(0,i.kt)("p",null,"The possible types a ",(0,i.kt)("inlineCode",{parentName:"p"},"Term")," can keep track of are defined in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/HarmonicLabs/plu-ts/tree/main/src/onchain/pluts/PTypes"},"PTypes"),", and listed here:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PUnit")," a unique value that has no real meaning; you can see it as ",(0,i.kt)("inlineCode",{parentName:"li"},"plu-ts")," version of ",(0,i.kt)("inlineCode",{parentName:"li"},"undefined")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," in Typescript"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PInt")," a signed integer that can be as big as you want"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PBool")," a boolean value"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PByteString")," equivalent of a ",(0,i.kt)("inlineCode",{parentName:"li"},"Buffer")," or a ",(0,i.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"},(0,i.kt)("inlineCode",{parentName:"a"},"Uint8Array"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PString")," equivalent of the Typescript ",(0,i.kt)("inlineCode",{parentName:"li"},"string")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PData")," equivalent of the ",(0,i.kt)("inlineCode",{parentName:"li"},"object")," type in Typescript (it is the low level representation of ",(0,i.kt)("inlineCode",{parentName:"li"},"PStruct"),"s that we'll cover in a moment, so you usually won't use ",(0,i.kt)("inlineCode",{parentName:"li"},"PData"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PList<PType>")," equivalent of an Array in Typescript; note that all the elements in the list must be of the same ",(0,i.kt)("inlineCode",{parentName:"li"},"PType")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PPair<PType1, PType2>")," equivalent of a Typescript tuple (",(0,i.kt)("inlineCode",{parentName:"li"},"[ type1 , type2 ]"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PDelayed<PType>")," a delayed computation that returns a value of type ",(0,i.kt)("inlineCode",{parentName:"li"},"PType"),"; the computation can be run by passing the delayed value to the ",(0,i.kt)("inlineCode",{parentName:"li"},"pforce")," function"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PLam<PInput, POutput>")," a function that takes one single argument of type ",(0,i.kt)("inlineCode",{parentName:"li"},"PInput")," and returns something of type ",(0,i.kt)("inlineCode",{parentName:"li"},"POutput")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PFn<[ PInput_0 , ...PType[] ],POutput>")," a function that takes multiple arguments (at least one) and returns something of type ",(0,i.kt)("inlineCode",{parentName:"li"},"POutput")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PAlias<PType>")," just an alias of the provided type; it behaves exactly like the Types of its argument, so ",(0,i.kt)("inlineCode",{parentName:"li"},"PAlias<PInt>")," is equivalent to a ",(0,i.kt)("inlineCode",{parentName:"li"},"PInt"),". This is useful for keeping track of a different meaning the type might have."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PStruct<{...}>")," an abstraction over ",(0,i.kt)("inlineCode",{parentName:"li"},"PData"),", useful to construct more complex data structures.")),(0,i.kt)("h2",{id:"plu-ts-types"},(0,i.kt)("inlineCode",{parentName:"h2"},"plu-ts")," Types"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," would not be a strongly typed language if limited to Typescript types, because the types of Typescript are only useful during compilation to javascript; and then everything is untyped!"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Typescript can be compiled to Javascript. When this happens, the resulting Javascript is untyped!"),(0,i.kt)("p",{parentName:"admonition"},"For this reason ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," implements its own type through some constants and functions that can be imported.")),(0,i.kt)("p",null,"In the same order of above, the ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," equivalents are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PUnit")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"unit")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PInt")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"int")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PBool")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"bool")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PByteString")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"bs")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PString")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"str")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PData")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PList")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"list( type )")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PPair")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"pair( type1, type2 )")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PDelayed")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"delayed( type )")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PLam")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"lam( from, to )")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PFn")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"fn([ ...inputs ], output )")),(0,i.kt)("li",{parentName:"ul"},"aliases types and structs types will be retreived by the ",(0,i.kt)("inlineCode",{parentName:"li"},"type")," static property of the classes (explained in the dedicated section for ",(0,i.kt)("a",{parentName:"li",href:"./Values/aliases"},"aliases")," and ",(0,i.kt)("a",{parentName:"li",href:"./Values/Structs/definition"},"structs"),")")),(0,i.kt)("h2",{id:"plu-ts-generics"},(0,i.kt)("inlineCode",{parentName:"h2"},"plu-ts")," generics"),(0,i.kt)("p",null,"As we know, Typescript gives us the possibility to define polymorphic types trough generics."),(0,i.kt)("p",null,"In a way you could see generics as ",(0,i.kt)("em",{parentName:"p"},"functions")," that take a type as input and returns another type."),(0,i.kt)("p",null,"Fortunately for us, ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," types are just values when seen from the Typescript world, so we can have some sort of generic in ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," too!"),(0,i.kt)("p",null,"To see how, let's try to define the previous polymorphic types using the generic method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const anyPlutsFunction = ( a: TermType, b: TermType ) => lam( a, b );\n\nconst identityFunctionType = ( a: TermType ) => lam( a, a );\n\nconst mkPairType = ( a: TermType, b: TermType ) => fn([ a, b ], pair( a, b ) )\n")),(0,i.kt)("p",null,"Polymorphic types defined as functions also have the advantage of being fully defined once the type arguments are passed."),(0,i.kt)("p",null,"This works great, but there's still a problem though... Typescript isn't able to infer these types!"),(0,i.kt)("p",null,"This is because ",(0,i.kt)("inlineCode",{parentName:"p"},"TermType")," is the generic type for all ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," types, so when Typescript tries to infer the type of the term, it sees the most generic type of all, and once again thinks we want to use the anonymous ",(0,i.kt)("inlineCode",{parentName:"p"},"PType"),"."),(0,i.kt)("p",null,"To finally solve this problem we need to make the functions generic too:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function anyFunction<A extends TermType, B extends TermType>( a: A, b: B )\n{ \n    return lam( a, b ) \n};\n\nfunction identityFunctionType<A extends TermType>( a: A )\n{ \n    return lam( a, a ) \n};\n\nfunction mkPairType<A extends TermType, B extends TermType>( a: A, b: B )\n{ \n    return fn([ a, b ], pair( a, b ) ) \n};\n")),(0,i.kt)("p",null,"This way Typescript first infers the specific ",(0,i.kt)("inlineCode",{parentName:"p"},"TermType")," we are passing, and with that is able to determine the exact type of the Term."),(0,i.kt)("p",null,"Generics will turn useful especially in the case where the type requires a type variable as return type, a notable example is ",(0,i.kt)("inlineCode",{parentName:"p"},"pif")," which is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"bool -> a -> a -> a"),"."))}c.isMDXComponent=!0}}]);