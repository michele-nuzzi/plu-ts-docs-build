"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[5306],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=o.createContext({}),l=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=l(e.components);return o.createElement(p.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=r,d=u["".concat(p,".").concat(h)]||u[h]||m[h]||i;return n?o.createElement(d,a(a({ref:t},c),{},{components:n})):o.createElement(d,a({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:r,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7525:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const i={sidebar_position:1},a="phoist",s={unversionedId:"onchain/Optimizations/phoist",id:"onchain/Optimizations/phoist",title:"phoist",description:"Another great tool for optimizations is phoist and all hoisted terms.",source:"@site/docs/onchain/Optimizations/phoist.mdx",sourceDirName:"onchain/Optimizations",slug:"/onchain/Optimizations/phoist",permalink:"/docs/onchain/Optimizations/phoist",draft:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts/tree/main/packages/create-docusaurus/templates/shared/docs/onchain/Optimizations/phoist.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"plet",permalink:"/docs/onchain/Optimizations/plet"},next:{title:"pforce and pdelay",permalink:"/docs/onchain/Optimizations/pforce and pdelay"}},p={},l=[{value:"Can I use <code>phoist</code> everywhere?",id:"can-i-use-phoist-everywhere",level:2}],c={toc:l},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"phoist"},(0,r.kt)("inlineCode",{parentName:"h1"},"phoist")),(0,r.kt)("p",null,"Another great tool for optimizations is ",(0,r.kt)("inlineCode",{parentName:"p"},"phoist")," and all ",(0,r.kt)("em",{parentName:"p"},"hoisted")," terms."),(0,r.kt)("admonition",{title:"Hoisting",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"( source: ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"},"MDN Docs/Hoisting")," )"),(0,r.kt)("blockquote",{parentName:"admonition"},(0,r.kt)("p",{parentName:"blockquote"},"Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior to execution of the code."))),(0,r.kt)("p",null,"You can think of ",(0,r.kt)("em",{parentName:"p"},"hoisted terms")," as terms that have been ",(0,r.kt)("inlineCode",{parentName:"p"},"plet"),"ted but in the global scope."),(0,r.kt)("p",null,"So once you use a hoisted term once, each time you re-use it you are adding almost ",(0,r.kt)("em",{parentName:"p"},"nothing")," to the script size."),(0,r.kt)("p",null,"You can create a hoisted term by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"phoist")," function. This allows you to reuse the term you hoisted as many times as you want."),(0,r.kt)("p",null,"This makes ",(0,r.kt)("inlineCode",{parentName:"p"},"phoist")," a great tool if you need to develop a library for ",(0,r.kt)("inlineCode",{parentName:"p"},"plu-ts"),"; because is likely your functions will be used a lot."),(0,r.kt)("p",null,"Let's say we wanted to create a library for math functions. We definitely want to have a way to calculate factorials;\nwe already defined ",(0,r.kt)("inlineCode",{parentName:"p"},"pfactorial")," while introducing ",(0,r.kt)("a",{parentName:"p",href:"../Control%20Flow/precursive"},"recursion"),", however that definition is not great if we need to re-use it a lot because the term is always inlined."),(0,r.kt)("p",null,"But now we know how to fix it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const pfactorial = \n    phoist( precursive(\n\n        pfn([\n            lam( int, int ),\n            int\n        ],  int)\n        \n        (( self, n ) =>\n            pif( int ).$(\n                n.ltEq( 1 )\n            )\n            .then( 1 )\n            .else(\n                self.$( n.sub( 1 ) )\n                .mult( n )\n            )\n        )\n\n    ))\n")),(0,r.kt)("p",null,"If you compare this definiton with the previous one you'll see that nothing has changed except for the ",(0,r.kt)("inlineCode",{parentName:"p"},"phoist"),", that's it; now we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"pfactorial")," as many times we want."),(0,r.kt)("h2",{id:"can-i-use-phoist-everywhere"},"Can I use ",(0,r.kt)("inlineCode",{parentName:"h2"},"phoist")," everywhere?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"No")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"phoist")," only accepts ",(0,r.kt)("em",{parentName:"p"},"closed terms")," (aka. Terms that do not contain external variables); if you pass a term that is not closed to ",(0,r.kt)("inlineCode",{parentName:"p"},"phoist")," it ",(0,r.kt)("strong",{parentName:"p"},"throws")," a ",(0,r.kt)("inlineCode",{parentName:"p"},"BasePlutsError")," error."),(0,r.kt)("p",null,"So things like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const fancyTerm = plam( int, int )\n    ( n => \n        // highlight-error\n        phoist( n.mult( 2 ) ); // error.\n    )\n")),(0,r.kt)("p",null,"will throw at compilation time because the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," comes from ",(0,r.kt)("em",{parentName:"p"},"outside")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"phoist")," function, hence the term is ",(0,r.kt)("em",{parentName:"p"},"open")," (not closed)."))}m.isMDXComponent=!0}}]);