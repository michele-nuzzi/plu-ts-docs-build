"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[90096],{30028:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>o});var t=n(17624),i=n(4552);const r={sidebar_position:1},d="Simple values",c={id:"onchain/Values/Simple Values",title:"Simple values",description:"For most of the types described there is a function to transform the Typescript version to the plu-ts equivalent.",source:"@site/docs/onchain/Values/Simple Values.mdx",sourceDirName:"onchain/Values",slug:"/onchain/Values/Simple Values",permalink:"/onchain/Values/Simple Values",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/onchain/Values/Simple Values.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Values",permalink:"/category/values"},next:{title:"Functions",permalink:"/category/functions"}},l={},o=[{value:"values constructors",id:"values-constructors",level:2},{value:"* <code>pList</code>",id:"-plist",level:2},{value:"** <code>pPair</code>",id:"-ppair",level:2},{value:"*** <code>delayed</code>",id:"-delayed",level:2}];function a(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"simple-values",children:"Simple values"}),"\n",(0,t.jsxs)(s.p,{children:["For most of the ",(0,t.jsx)(s.a,{href:"../Types",children:"types"})," described there is a function to transform the Typescript version to the ",(0,t.jsx)(s.code,{children:"plu-ts"})," equivalent."]}),"\n",(0,t.jsxs)(s.p,{children:["Here we cover the simple ones, leaving ",(0,t.jsx)(s.a,{href:"./Functions/plam_and_pfn",children:"functions"})," and ",(0,t.jsx)(s.a,{href:"./Structs/definition",children:"structs"})," to be covered later."]}),"\n",(0,t.jsx)(s.h2,{id:"values-constructors",children:"values constructors"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.th,{children:[(0,t.jsx)(s.code,{children:"plu-ts"})," type"]}),(0,t.jsx)(s.th,{children:"function name"}),(0,t.jsxs)(s.th,{children:["ts to ",(0,t.jsx)(s.code,{children:"plu-ts"})," function signature"]})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"unit"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pmakeUnit"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pmakeUnit(): Term<PUnit>"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"int"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pInt"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pInt(x: number \\ bigint): Term<PInt>"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"bool"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pBool"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pBool(x: boolean): Term<PBool>"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"bs"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pByteString"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pByteString(x: string \\ ByteString \\ Buffer): Term<PByteString>"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"str"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pStr"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pStr(x: string): Term<PStr>"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"data"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pData"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pData(x: Data): Term<PData>"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"list"})}),(0,t.jsx)(s.td,{children:(0,t.jsxs)(s.a,{href:"#-plist",children:[(0,t.jsx)(s.code,{children:"pList"}),"*"]})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pList<T extends TermType>( t: T )( x: Term<ToPType<T>>[] )"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pair"})}),(0,t.jsx)(s.td,{children:(0,t.jsxs)(s.a,{href:"#-ppair",children:[(0,t.jsx)(s.code,{children:"pPair"}),"**"]})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pPair<A extends TermType, B extends TermType>( fstT: A, sndT: B )( fst: Term<ToPType<A>>, snd: Term<ToPType<B>> )"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"delayed"})}),(0,t.jsx)(s.td,{children:"*** not supported at ts level"}),(0,t.jsx)(s.td,{children:"*** explained below"})]})]})]}),"\n",(0,t.jsxs)(s.h2,{id:"-plist",children:["* ",(0,t.jsx)(s.code,{children:"pList"})]}),"\n",(0,t.jsxs)(s.p,{children:["Since ",(0,t.jsx)(s.code,{children:"PList"})," is a generic type the ",(0,t.jsx)(s.code,{children:"pList"})," function has a slightly more complex function signature:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"function pList<ElemsT extends TermType, PElemsT extends ToPType<ElemsT = ToPType<ElemsT>>>\n    ( elemsT: ElemsT )\n    : ( elems: Term<PElemsT>[] ) => Term<PList<PElemsT>>\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In the signature above, ",(0,t.jsx)(s.code,{children:"TermType"})," is the Typescript types of ",(0,t.jsx)(s.code,{children:"plu-ts"})," types (which are typescript values after all) and ",(0,t.jsx)(s.code,{children:"ToPType"})," is a utility type used internally and you should not worry about it."]}),"\n",(0,t.jsxs)(s.p,{children:["From the signature we can already understand that given a ",(0,t.jsx)(s.code,{children:"plu-ts"})," type, ",(0,t.jsx)(s.code,{children:"pList"})," returns a function ad-hoc for terms of that type; so if we want a function to get list of integers we just do:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"const pListInt: ( elems: Term<PInt>[] ) => Term<PList<PInt>> = \n    pList( int );\n"})}),"\n",(0,t.jsx)(s.p,{children:"And with that we now have a function that transforms an array of terms into a list."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"const intList = pListInt( [1,2,3,4].map( pInt ) );\n"})}),"\n",(0,t.jsxs)(s.p,{children:["You might notice that in contrast to the other functions introduced, ",(0,t.jsx)(s.code,{children:"pListInt"})," that we created works with terms instead of vanilla ts values; this is because ",(0,t.jsx)(s.code,{children:"pListInt"})," acts as a macro as seen by ",(0,t.jsx)(s.code,{children:"plu-ts"}),"."]}),"\n",(0,t.jsxs)(s.h2,{id:"-ppair",children:["** ",(0,t.jsx)(s.code,{children:"pPair"})]}),"\n",(0,t.jsxs)(s.p,{children:["Just like ",(0,t.jsx)(s.code,{children:"PList"}),", also ",(0,t.jsx)(s.code,{children:"PPair"})," is a generic type, which causes ",(0,t.jsx)(s.code,{children:"pPair"})," to have more complex function signature too:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"function pPair<\n    A extends TermType, \n    B extends TermType, \n    PA extends ToPType<A> = ToPType<A>,\n    PA extends ToPType<B> = ToPType<B>,\n>\n    ( fstT: A, sndT: B )\n    : ( fst: PappArg<PA>, snd: PappArg<PB> ) => Term<PPair<PA,PB>>\n"})}),"\n",(0,t.jsxs)(s.p,{children:["and you would use it in a very similar way of ",(0,t.jsx)(s.code,{children:"pList"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:'const myPair = pPair( bs, int )( "caffee", 2 )\n'})}),"\n",(0,t.jsxs)(s.admonition,{type:"info",children:[(0,t.jsxs)(s.p,{children:["Note how we are passing typescript value without transforming them to ",(0,t.jsx)(s.code,{children:"plu-ts"})," ones;"]}),(0,t.jsx)(s.p,{children:"This is some magic done by 'plu-ts' so that if the type is known we don't have to explicitly construct it."}),(0,t.jsx)(s.p,{children:"We'll see that this turns really useful while writing a smart contract"})]}),"\n",(0,t.jsxs)(s.h2,{id:"-delayed",children:["*** ",(0,t.jsx)(s.code,{children:"delayed"})]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"delayed"})," doesn't really have a Typescript value, so it only makes sense in the ",(0,t.jsx)(s.code,{children:"plu-ts"})," world."]}),"\n",(0,t.jsxs)(s.p,{children:["You can only obtain a delayed value from an exsisting one using ",(0,t.jsx)(s.code,{children:"pdelay"})]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"function pdelay<PT extends PType>( someTerm: Term<PT> ): Term<PDelayed<PT>>\n"})})]})}function h(e={}){const{wrapper:s}={...(0,i.M)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},4552:(e,s,n)=>{n.d(s,{I:()=>c,M:()=>d});var t=n(11504);const i={},r=t.createContext(i);function d(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);