"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[5928],{53688:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>a});var i=t(17624),o=t(4552);const s={sidebar_position:4},d="PBound",r={id:"onchain/API/types/V1/Interval/PBound",title:"PBound",description:"Represents a bound in a range with an associated inclusivity flag.",source:"@site/docs/onchain/API/types/V1/Interval/PBound.mdx",sourceDirName:"onchain/API/types/V1/Interval",slug:"/onchain/API/types/V1/Interval/PBound",permalink:"/onchain/API/types/V1/Interval/PBound",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/onchain/API/types/V1/Interval/PBound.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Interval",permalink:"/category/interval"},next:{title:"PExtended",permalink:"/onchain/API/types/V1/Interval/PExtended"}},c={},a=[{value:"<code>bound</code>",id:"bound",level:2},{value:"<code>inclusive</code>",id:"inclusive",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"pbound",children:(0,i.jsx)(n.code,{children:"PBound"})}),"\n",(0,i.jsxs)(n.p,{children:["Represents a bound in a range with an associated inclusivity flag.\nThe ",(0,i.jsx)(n.code,{children:"PBound"})," type is typically used to define the bounds of an interval, where each bound is either inclusive or exclusive, and the value of the bound itself is described by an ",(0,i.jsx)(n.code,{children:"PExtended"})," type."]}),"\n",(0,i.jsx)(n.p,{children:"Definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { pstruct } from "../../../PTypes/PStruct/pstruct";\nimport { bool } from "../../../type_system/types";\nimport { PExtended } from "./PExtended";\n\nexport const PBound = pstruct({\n    PBound: {\n        bound: PExtended.type,\n        inclusive: bool \n    }\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"bound",children:(0,i.jsx)(n.code,{children:"bound"})}),"\n",(0,i.jsxs)(n.p,{children:["This field specifies the actual value of the boundary in the interval. This can either be a concrete value or an infinite one (i.e., open-ended bound).\nThe ",(0,i.jsx)(n.code,{children:"PExtended"})," type allows for this flexibility by supporting both finite and infinite bounds."]}),"\n",(0,i.jsxs)(n.p,{children:["type: ",(0,i.jsx)(n.a,{href:"./PExtended",children:(0,i.jsx)(n.code,{children:"PExtended"})})]}),"\n",(0,i.jsx)(n.h3,{id:"inclusive",children:(0,i.jsx)(n.code,{children:"inclusive"})}),"\n",(0,i.jsx)(n.p,{children:"A boolean flag that indicates whether the bound is inclusive or exclusive, meaning part or not part of the interval"}),"\n",(0,i.jsxs)(n.p,{children:["type: ",(0,i.jsx)(n.a,{href:"../../../../stdlib/TermBool",children:(0,i.jsx)(n.code,{children:"bool"})})]})]})}function u(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},4552:(e,n,t)=>{t.d(n,{I:()=>r,M:()=>d});var i=t(11504);const o={},s=i.createContext(o);function d(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);