"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[9716],{16996:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=n(17624),r=n(4552);n(61268),n(87768);const o={sidebar_position:0,titiel:"Hello World"},i="Hello plu-ts",l={id:"examples/Hello_World",title:"Hello plu-ts",description:"In this example project we'll write our first smart contract and interact with it using the CIP-0030 standard.",source:"@site/docs/examples/Hello_World.mdx",sourceDirName:"examples",slug:"/examples/Hello_World",permalink:"/examples/Hello_World",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/examples/Hello_World.mdx",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,titiel:"Hello World"},sidebar:"tutorialSidebar",previous:{title:"Hello plu-ts",permalink:"/examples/Hello_world_v0"},next:{title:"Vesting",permalink:"/examples/Vesting"}},a={},c=[{value:"Pre-requisites",id:"pre-requisites",level:2},{value:"Project set up",id:"project-set-up",level:2},{value:"Project overview",id:"project-overview",level:3},{value:"The contract",id:"the-contract",level:2},{value:"Introduce an <code>owner</code>",id:"introduce-an-owner",level:3},{value:"Send messages to the contracts",id:"send-messages-to-the-contracts",level:3},{value:"Implement the logic",id:"implement-the-logic",level:3},{value:"Lock some funds",id:"lock-some-funds",level:2},{value:"<code>myAddr</code>",id:"myaddr",level:3},{value:"<code>txBuilder</code>",id:"txbuilder",level:3},{value:"<code>myUTxOs</code>",id:"myutxos",level:3},{value:"<code>utxo</code>",id:"utxo",level:3},{value:"Build and return the transaction",id:"build-and-return-the-transaction",level:3},{value:"Test it out",id:"test-it-out",level:3},{value:"Unlock the funds",id:"unlock-the-funds",level:2},{value:"<code>txBuilder</code> and <code>myUTxOs</code>",id:"txbuilder-and-myutxos",level:3},{value:"<code>myAddrs</code> and <code>myAddr</code>",id:"myaddrs-and-myaddr",level:3},{value:"Get the script&#39;s utxos",id:"get-the-scripts-utxos",level:3},{value:"Build the transaction",id:"build-the-transaction",level:3},{value:"Test the contract",id:"test-the-contract",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"hello-plu-ts",children:"Hello plu-ts"}),"\n",(0,s.jsxs)(t.p,{children:["In this example project we'll write our first smart contract and interact with it using the ",(0,s.jsx)(t.a,{href:"https://cips.cardano.org/cips/cip30/",children:"CIP-0030"})," standard."]}),"\n",(0,s.jsxs)(t.p,{children:["The final verision of this project is available ",(0,s.jsx)(t.a,{href:"https://github.com/michele-nuzzi/hello-pluts-react-final",children:"here"})," and you can test it out in the ",(0,s.jsx)(t.a,{href:"https://hello-pluts.harmoniclabs.tech/",children:"live demo"}),"."]}),"\n",(0,s.jsxs)(t.admonition,{title:"old version of this example project",type:"note",children:[(0,s.jsxs)(t.p,{children:["If you are looking for the old version of this example project you can ",(0,s.jsx)(t.a,{href:"./Hello_world_v0",children:"click here"})," to check it out."]}),(0,s.jsxs)(t.p,{children:["We would also highlight the ",(0,s.jsx)(t.a,{href:"https://www.youtube.com/watch?v=b6MaSz6NIh8&themeRefresh=1",children:"useful run trough of the old example"})," created by our community members"]})]}),"\n",(0,s.jsx)(t.h2,{id:"pre-requisites",children:"Pre-requisites"}),"\n",(0,s.jsx)(t.p,{children:"All we need to build a dApp is:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"plu-ts"})}),"\n",(0,s.jsx)(t.li,{children:"Some way to submit transactions."}),"\n",(0,s.jsxs)(t.li,{children:["React + ",(0,s.jsx)(t.a,{href:"https://meshjs.dev/",children:(0,s.jsx)(t.code,{children:"MeshSDK"})})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["In fact, ",(0,s.jsx)(t.code,{children:"plu-ts"})," allows you to write the smart contract and create transactions."]}),"\n",(0,s.jsxs)(t.p,{children:["To submit the transaction we will use ",(0,s.jsx)(t.a,{href:"../tools/blockfrost-pluts",children:(0,s.jsx)(t.code,{children:"blockfrost-pluts"})}),", a wrapper on top of the ",(0,s.jsx)(t.a,{href:"https://blockfrost.io/",children:"Blockfrost"})," API that uses ",(0,s.jsx)(t.code,{children:"plu-ts"})," offchain types;\nbut we'll talk about that later."]}),"\n",(0,s.jsx)(t.p,{children:"So for now our pre-requisites add up to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"plu-ts"})," (and ",(0,s.jsx)(t.code,{children:"npm"})," to install it)"]}),"\n",(0,s.jsx)(t.li,{children:"Anything that can run javascript (server environment or browser, doesn't matter)"}),"\n",(0,s.jsx)(t.li,{children:"An internet connection"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"project-set-up",children:"Project set up"}),"\n",(0,s.jsxs)(t.p,{children:["Using ",(0,s.jsx)(t.code,{children:"git"})," we clone the initial ",(0,s.jsx)(t.code,{children:"hello-pluts-react"})," project form ",(0,s.jsx)(t.a,{href:"https://github.com/HarmonicLabs/hello-pluts-react",children:"github"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"git clone https://github.com/HarmonicLabs/hello-pluts-react.git\ncd hello-pluts-react\ngit remote remove origin\n"})}),"\n",(0,s.jsx)(t.p,{children:"This gives us the following project structure:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"./hello-pluts-react\n\u251c\u2500\u2500 contracts\n\u2502   \u2514\u2500\u2500 helloPluts.ts\n\u251c\u2500\u2500 next.config.js\n\u251c\u2500\u2500 next-env.d.ts\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 components\n\u2502   \u2502   \u2514\u2500\u2500 ConnectionHandler.tsx\n\u2502   \u251c\u2500\u2500 offchain\n\u2502   \u2502   \u251c\u2500\u2500 getTxBuilder.ts\n\u2502   \u2502   \u251c\u2500\u2500 lockTx.ts\n\u2502   \u2502   \u251c\u2500\u2500 mesh-utils.ts\n\u2502   \u2502   \u2514\u2500\u2500 unlockTx.ts\n\u2502   \u251c\u2500\u2500 pages\n\u2502   \u2502   \u251c\u2500\u2500 _app.tsx\n\u2502   \u2502   \u251c\u2500\u2500 _document.tsx\n\u2502   \u2502   \u2514\u2500\u2500 index.tsx\n\u2502   \u2514\u2500\u2500 styles\n\u2502       \u251c\u2500\u2500 globals.css\n\u2502       \u2514\u2500\u2500 Home.module.css\n\u2514\u2500\u2500 tsconfig.json\n"})}),"\n",(0,s.jsx)(t.p,{children:"The project comes with all the dependencies we need;"}),"\n",(0,s.jsx)(t.p,{children:"The most important ones are:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",metastring:'title="package.json"',children:'"dependencies": {\n    "@harmoniclabs/plu-ts": "^0.7.0",\n    "@harmoniclabs/uint8array-utils": "^1.0.0",\n    "@harmoniclabs/blockfrost-pluts": "^0.1.11",\n    "@meshsdk/core": "^1.5.2",\n    "@meshsdk/react": "^1.1.7",\n    /* other deps */\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["So now we only need to run ",(0,s.jsx)(t.code,{children:"npm install"})," to automatically add them."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"npm install\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"Et voil\xe0"})," we are ready to start!"]}),"\n",(0,s.jsx)(t.h3,{id:"project-overview",children:"Project overview"}),"\n",(0,s.jsxs)(t.p,{children:["From the project structure we see that the code can be found in the ",(0,s.jsx)(t.code,{children:"src"})," folder and the ",(0,s.jsx)(t.code,{children:"contracts"})," folder."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"contracts"})," only file is the ",(0,s.jsx)(t.code,{children:"helloPluts.ts"})," one; which for now contains only a contract that always fails and exports the compiled result."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="contracts/helloPluts.ts"',children:'import { Address, PPubKeyHash, PScriptContext, PaymentCredentials, Script, bool, bs, compile, makeValidator, pfn, data, pBool } from "@harmoniclabs/plu-ts";\n\nconst helloPluts = pfn([\n  data,\n  data,\n  PScriptContext.type\n], bool)\n((datum, redeemer, ctx) => {\n  // locks funds forever\n  return pBool( false );\n});\n\n///////////////////////////////////////////////////////////////////\n// ------------------------------------------------------------- //\n// ------------------------- utilities ------------------------- //\n// ------------------------------------------------------------- //\n///////////////////////////////////////////////////////////////////\n\nexport const untypedValidator = makeValidator(helloPluts);\n\nexport const compiledContract = compile(untypedValidator);\n\nexport const script = new Script(\n  "PlutusScriptV2",\n  compiledContract\n);\n\nexport const scriptTestnetAddr = new Address(\n  "testnet",\n  PaymentCredentials.script(script.hash)\n);\n'})}),"\n",(0,s.jsx)(t.p,{children:"We'll come back on this file later."}),"\n",(0,s.jsxs)(t.p,{children:["The other two files we'll work with are ",(0,s.jsx)(t.code,{children:"src/offchain/lockTx.ts"})," and ",(0,s.jsx)(t.code,{children:"src/offchain/unlockTx.ts"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Both very similar:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/offchain/lockTx.ts"',children:'import { Value, DataB, Address, Tx } from "@harmoniclabs/plu-ts";\nimport { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\nimport { BrowserWallet } from "@meshsdk/core";\nimport { scriptTestnetAddr } from "../../contracts/helloPluts";\nimport { toPlutsUtxo } from "./mesh-utils";\nimport getTxBuilder from "./getTxBuilder";\n\nasync function getLockTx(wallet: BrowserWallet, Blockfrost: BlockfrostPluts): Promise<Tx> {\n  throw new Error("\'lockTx\' logic not implemented");\n}\n\nexport async function lockTx(wallet: BrowserWallet, projectId: string): Promise<string> {\n  const Blockfrost = new BlockfrostPluts({ projectId });\n  const unsingedTx = await getLockTx(wallet, Blockfrost);\n  const txStr = await wallet.signTx(unsingedTx.toCbor().toString());\n  return await Blockfrost.submitTx(txStr);\n}\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/offchain/unlockTx.ts"',children:'import { Address, isData, DataB, Tx } from "@harmoniclabs/plu-ts";\nimport { fromAscii, uint8ArrayEq } from "@harmoniclabs/uint8array-utils";\nimport { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\nimport { BrowserWallet } from "@meshsdk/core";\nimport { script, scriptTestnetAddr } from "../../contracts/helloPluts";\nimport { toPlutsUtxo } from "./mesh-utils";\nimport getTxBuilder from "./getTxBuilder";\n\nasync function getUnlockTx(wallet: BrowserWallet, Blockfrost: BlockfrostPluts): Promise<Tx> {\n  throw new Error("\'unlockTx\' logic not implemented");   \n}\n\nexport async function unlockTx(wallet: BrowserWallet, projectId: string): Promise<string> {\n  const Blockfrost = new BlockfrostPluts({ projectId });\n  const unsingedTx = await getUnlockTx(wallet, Blockfrost);\n\n  const txStr = await wallet.signTx(\n    unsingedTx.toCbor().toString(),\n    true // partial sign because we have smart contracts in the transaction\n  );\n\n  return await Blockfrost.submitTx(txStr);\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Our work later in this project will be to create the transactions that will interact with the contract."}),"\n",(0,s.jsxs)(t.p,{children:["This will be done using the plu-ts ",(0,s.jsx)(t.a,{href:"../offchain/TxBuilder%20API/TxBuilder",children:(0,s.jsx)(t.code,{children:"TxBuilder"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The code to get a ",(0,s.jsx)(t.code,{children:"TxBuilder"})," instance is already defined in the ",(0,s.jsx)(t.code,{children:"src/offchain/getTxBuilder.ts"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/offchain/getTxBuilder.ts"',children:'import { TxBuilder } from "@harmoniclabs/plu-ts";\nimport { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\n\n/**\n * we don\'t want to do too many API call if we already have our `txBuilder`\n * \n * so after the first call we\'ll store a copy here.\n**/\nlet _cachedTxBuilder: TxBuilder | undefined = undefined\n\nexport default async function getTxBuilder(Blockfrost: BlockfrostPluts): Promise<TxBuilder> {\n  if (!(_cachedTxBuilder instanceof TxBuilder)) {\n    const parameters = await Blockfrost.epochsLatestParameters();\n    _cachedTxBuilder = new TxBuilder(parameters);\n  }\n  return _cachedTxBuilder;\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Constructing a ",(0,s.jsx)(t.code,{children:"TxBuilder"})," requires us to pass the protocol parameters of the chain we are operating in."]}),"\n",(0,s.jsxs)(t.p,{children:["To get the protocol parameters we are using a ",(0,s.jsx)(t.code,{children:"Blockfrost"})," object."]}),"\n",(0,s.jsx)(t.p,{children:"Then there is the website."}),"\n",(0,s.jsxs)(t.p,{children:["This is a very simple ",(0,s.jsx)(t.a,{href:"https://nextjs.org/",children:"Next.js"})," project, of which the only page is in ",(0,s.jsx)(t.code,{children:"src/pages/index.tsx"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:'title="src/pages/index.tsx"',children:'import { useState } from "react";\nimport { Container, Box, Text, Button, Input, useToast } from "@chakra-ui/react";\nimport { useNetwork, useWallet } from "@meshsdk/react";\n\nimport style from "@/styles/Home.module.css";\nimport ConnectionHandler from "@/components/ConnectionHandler";\nimport { lockTx } from "@/offchain/lockTx";\nimport { unlockTx } from "@/offchain/unlockTx";\n\nexport default function Home() {\n  const [blockfrostApiKey, setBlockfrostApiKey] = useState<string>(\'\');\n  const {wallet, connected} = useWallet();\n  const network = useNetwork();\n  const toast = useToast();\n\n  if (typeof network === "number" && network !== 0) {\n    return (\n      <div className={style.root}>\n        <Container maxW="container.sm" py={12} centerContent>\n          <Box bg="white" w="100%" p={8}>\n            <Text fontSize="xl" mb={6}>Make sure to set your wallet in testnet mode;<br/>We are playing with founds here!</Text>\n            <Button size="lg" colorScheme="blue" onClick={() => window.location.reload()}>Refresh page</Button>\n          </Box>\n        </Container>\n      </div>\n    )\n  }\n\n  const onLock = () => {\n    lockTx(wallet, blockfrostApiKey)\n      // lock transaction created successfully\n      .then(txHash => toast({\n        title: `lock tx submitted: https://preprod.cardanoscan.io/transaction/${txHash}`,\n        status: "success"\n      }))\n      // lock transaction failed\n      .catch(e => {\n        toast({\n          title: "something went wrong",\n          status: "error"\n        });\n        console.error(e);\n      });\n  }\n\n  const onUnlock = () => {\n    unlockTx(wallet, blockfrostApiKey)\n      // unlock transaction created successfully\n      .then(txHash => toast({\n        title: `unlock tx submitted: https://preprod.cardanoscan.io/transaction/${txHash}`,\n        status: "success"\n      }))\n      // unlock transaction failed\n      .catch(e => {\n        toast({\n          title: "something went wrong",\n          status: "error"\n        });\n        console.error(e);\n      });\n  }\n\n  return (\n    <div className={style.root}>\n      <Container maxW="container.sm" py={12} centerContent>\n        <Box bg="white" w="100%" p={4} mb={4}>\n          <Text fontSize="md" mb={4}>\n            In order to run this example you need to provide a Blockfrost API Key<br />\n            More info on <a href="https://blockfrost.io/" target="_blank" style={{color:\'#0BC5EA\'}}>blockfrost.io</a>\n          </Text>\n          <Input\n            variant=\'filled\'\n            placeholder=\'Blockfrost API Key\'\n            size=\'lg\'\n            value={blockfrostApiKey}\n            onChange={e => setBlockfrostApiKey(e.target.value)}\n          />\n        </Box>\n        <Box bg="white" w="100%" p={4}>\n          <ConnectionHandler isDisabled={blockfrostApiKey === \'\'} />\n          {connected && (\n            <>\n              <Button size="lg" ml={4} colorScheme="teal" isDisabled={blockfrostApiKey === \'\'} onClick={onLock}>Lock 10 tADA</Button>\n              <Button size="lg" ml={4} colorScheme="teal" isDisabled={blockfrostApiKey === \'\'} onClick={onUnlock}>Unlock</Button>\n            </>\n          )}\n        </Box>\n      </Container>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"All the logic of the user interface (UI) is happening here."}),"\n",(0,s.jsxs)(t.p,{children:["We are using the ",(0,s.jsx)(t.code,{children:"useNetwork"})," react hook imported from ",(0,s.jsx)(t.a,{href:"https://meshjs.dev/react/wallet-hooks",children:(0,s.jsx)(t.code,{children:"@meshsdk/react"})}),"\njust to prevent users to play with the contract in mainnet."]}),"\n",(0,s.jsxs)(t.p,{children:["But the cool part is the ",(0,s.jsx)(t.code,{children:"useWallet"})," hook that gives us access to the user's wallet once connected."]}),"\n",(0,s.jsxs)(t.p,{children:["The connection happens in the ",(0,s.jsx)(t.code,{children:"ConnectionHandler"})," component we defined in ",(0,s.jsx)(t.code,{children:"src/components/ConnectionHandler.ts"}),".\nYou can check it yourself if you want to see how easy the connection process becomes with ",(0,s.jsx)(t.a,{href:"https://meshjs.dev/react/wallet-hooks",children:(0,s.jsx)(t.code,{children:"@meshsdk/react"})})]}),"\n",(0,s.jsx)(t.p,{children:"And with that this is it."}),"\n",(0,s.jsx)(t.p,{children:"You can try this web application running"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"npm run dev\n"})}),"\n",(0,s.jsx)(t.p,{children:"This will output something like the following"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"> hello-pluts-react@0.1.0 dev\n> next dev\n\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\n"})}),"\n",(0,s.jsx)(t.p,{children:"The numbers may vary a little but that is not a problem."}),"\n",(0,s.jsxs)(t.p,{children:["You can check out the website going to the specified url; in the example above is ",(0,s.jsx)(t.code,{children:"http://localhost:3000"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"However at this very moment the app won't do much."}),"\n",(0,s.jsx)(t.p,{children:"So let's start by defining what the contract should do."}),"\n",(0,s.jsx)(t.h2,{id:"the-contract",children:"The contract"}),"\n",(0,s.jsx)(t.p,{children:"We want to personalize the smart contract so that:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"It suceeds if the transaction is signed by us."}),"\n",(0,s.jsx)(t.li,{children:"And we are being polite by saluting the contract."}),"\n"]}),"\n",(0,s.jsxs)(t.h3,{id:"introduce-an-owner",children:["Introduce an ",(0,s.jsx)(t.code,{children:"owner"})]}),"\n",(0,s.jsxs)(t.p,{children:["To make sure the transaction is signed by us we'll keep track of an ",(0,s.jsx)(t.code,{children:"owner"})," in the datum (the first argument we saw in the contract)."]}),"\n",(0,s.jsx)(t.admonition,{title:"datum",type:"tip",children:(0,s.jsx)(t.p,{children:"The datum helps us keep track of the history of the input the smart contract is validating."})}),"\n",(0,s.jsxs)(t.p,{children:["Currently our datum is a generic ",(0,s.jsx)(t.code,{children:"data"})," argument, but it could be really anything;"]}),"\n",(0,s.jsx)(t.p,{children:"In our case all we need to keep track of is an owner"}),"\n",(0,s.jsx)(t.p,{children:"And that can be identified using a public key hash."}),"\n",(0,s.jsxs)(t.p,{children:["So in ",(0,s.jsx)(t.code,{children:"src/contract.ts"})," we'll change the first ",(0,s.jsx)(t.code,{children:"data"})," to ",(0,s.jsx)(t.a,{href:"../onchain/API/types/PPubKeyHash",children:(0,s.jsx)(t.code,{children:"PPubKeyHash"})})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"/* imports */\n\nconst helloPluts = pfn([\n  // highlight-next-line\n  PPubKeyHash.type,\n  data,\n  PScriptContext.type\n], bool)\n// highlight-next-line\n//  datum -> owner\n// highlight-next-line\n((owner, redeemer, ctx) => {\n  // locks funds forever\n  return pBool( false );\n});\n\n/* ... */\n"})}),"\n",(0,s.jsx)(t.h3,{id:"send-messages-to-the-contracts",children:"Send messages to the contracts"}),"\n",(0,s.jsx)(t.p,{children:"The second condition requires us to send some message to the contract."}),"\n",(0,s.jsx)(t.p,{children:"This is done thanks to the redeemer (or the second argument of a validator)."}),"\n",(0,s.jsx)(t.admonition,{title:"redeemer",type:"info",children:(0,s.jsx)(t.p,{children:"The redeemer is the argument specified by the user that interacts with the smart contract"})}),"\n",(0,s.jsxs)(t.p,{children:["Once again, all we need in order to have a message is just a ",(0,s.jsx)(t.code,{children:"bytestring"}),", nothing more complex,"]}),"\n",(0,s.jsxs)(t.p,{children:["So we'll change the second ",(0,s.jsx)(t.code,{children:"data"})," to the primitive type ",(0,s.jsx)(t.code,{children:"bs"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"/* imports */\n\nconst helloPluts = pfn([\n  PPubKeyHash.type,\n  // highlight-next-line\n  bs,\n  PScriptContext.type\n], bool)\n// highlight-next-line\n//  redeemer -> message\n// highlight-next-line\n((owner, message, ctx) => {\n  // locks funds forever\n  return pBool( false );\n});\n\n/* ... */\n"})}),"\n",(0,s.jsx)(t.h3,{id:"implement-the-logic",children:"Implement the logic"}),"\n",(0,s.jsx)(t.p,{children:"Finally we'll check both the conditions in the body of the function."}),"\n",(0,s.jsx)(t.p,{children:"So we'll first create a term that checks that the message is the one expected:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'const isBeingPolite = message.eq("Hello plu-ts");\n'})}),"\n",(0,s.jsx)(t.p,{children:"Then we'll check that the transaction is signed by the owner specified in the datum."}),"\n",(0,s.jsx)(t.p,{children:"To do so we need information about the transaction and who signed it."}),"\n",(0,s.jsxs)(t.p,{children:["All the information about the transaction is in the ",(0,s.jsx)(t.code,{children:"tx"})," field of the ",(0,s.jsx)(t.a,{href:"/onchain/API/types/PScriptContext",children:(0,s.jsx)(t.code,{children:"PScriptContext"})})]}),"\n",(0,s.jsxs)(t.p,{children:["An in particular we are interested in the ",(0,s.jsxs)(t.a,{href:"../onchain/API/types/PTxInfo#signatories",children:[(0,s.jsx)(t.code,{children:"signatories"})," field"]})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"ctx.tx.signatories;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Since this is a list of all the required signatories we chan use all the ",(0,s.jsx)(t.a,{href:"../onchain/stdlib/TermList",children:(0,s.jsx)(t.code,{children:"TermList"})})," methods;\nof which ",(0,s.jsx)(t.a,{href:"../onchain/stdlib/TermList#some",children:(0,s.jsx)(t.code,{children:"some"})})," allows us to check that ",(0,s.jsx)(t.strong,{children:"at leat one"})," element of the list respects a given property:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const signedByOwner = ctx.tx.signatories.some(owner.eq);\n"})}),"\n",(0,s.jsx)(t.p,{children:"And finally, we put all together"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:'import { Address, PPubKeyHash, PScriptContext, PaymentCredentials, Script, bool, bs, compile, makeValidator, pfn } from "@harmoniclabs/plu-ts";\n\nconst helloPluts = pfn([\n  PPubKeyHash.type,\n  bs,\n  PScriptContext.type\n], bool)\n((owner, message, ctx) => {\n  // highlight-start\n  const isBeingPolite = message.eq("Hello plu-ts");\n  const signedByOwner = ctx.tx.signatories.some(owner.eq);\n  return isBeingPolite.and(signedByOwner);\n  // highlight-end\n});\n\n/* ... */\n'})}),"\n",(0,s.jsx)(t.p,{children:"And this is it! this is our contract."}),"\n",(0,s.jsx)(t.p,{children:"To test it however we need to create transactions with it..."}),"\n",(0,s.jsx)(t.h2,{id:"lock-some-funds",children:"Lock some funds"}),"\n",(0,s.jsx)(t.p,{children:"In order for the smart contract to run it first needs something to spend;\nso now we will build a transaction that sends some funds to the contract\nand provides the datum that will be used when the funds we are sending are spent."}),"\n",(0,s.jsxs)(t.admonition,{title:"datum",type:"info",children:[(0,s.jsx)(t.p,{children:"As said before the datum acts as the contract local memory."}),(0,s.jsx)(t.p,{children:"For this reason we must set it now that we are funding the contract;\nas such; the datum is not provided in the spending transaction\n(or if it is it has to match the one that was setted in the transaction before;\notherwise the transaction is invalid)"})]}),"\n",(0,s.jsx)(t.p,{children:"So far what we have is this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/offchain/lockTx.ts"',children:"async function getLockTx(wallet: BrowserWallet, Blockfrost: BlockfrostPluts): Promise<Tx> {\n  throw new Error(\"'lockTx' logic not implemented\");\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"myaddr",children:(0,s.jsx)(t.code,{children:"myAddr"})}),"\n",(0,s.jsx)(t.p,{children:"The function takes as input the wallet with which the user is connected."}),"\n",(0,s.jsx)(t.p,{children:"The first thing we can do with the wallet is to request the user address"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"await wallet.getChangeAddress()\n"})}),"\n",(0,s.jsxs)(t.p,{children:["That expresion returns a string which is a cardano address in bech32 format (",(0,s.jsx)(t.code,{children:'"addr_test1v..."'}),")"]}),"\n",(0,s.jsxs)(t.p,{children:["A string isn't really that useful, so we'll use that to build a plu-ts ",(0,s.jsx)(t.code,{children:"Address"})," instance:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const myAddr = Address.fromString(\n  await wallet.getChangeAddress()\n);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"txbuilder",children:(0,s.jsx)(t.code,{children:"txBuilder"})}),"\n",(0,s.jsxs)(t.p,{children:["Since we want to build a transaction here it might be a good idea to have a ",(0,s.jsx)(t.code,{children:"TxBuilder"})," instance to help us."]}),"\n",(0,s.jsxs)(t.p,{children:["We already have the code to create one in the ",(0,s.jsx)(t.code,{children:"src/offchain/getTxBuilder.ts"})," file; so we just need to import it and call the function"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const txBuilder = await getTxBuilder();\n"})}),"\n",(0,s.jsx)(t.h3,{id:"myutxos",children:(0,s.jsx)(t.code,{children:"myUTxOs"})}),"\n",(0,s.jsx)(t.p,{children:"A transaction expects as input some output of a previous transaction that hasn't been spent yet;"}),"\n",(0,s.jsxs)(t.p,{children:["People call this stuff UTxO (",(0,s.jsx)(t.strong,{children:"U"}),"nspent ",(0,s.jsx)(t.strong,{children:"T"}),"ransa",(0,s.jsx)(t.em,{children:"ct"}),"ion ",(0,s.jsx)(t.strong,{children:"O"}),"utput)."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"BrowserWallet"})," turns ourselves useful once again here; we can get the wallet utxos calling"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"await wallet.getUtxos();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["However, since this is a function defined by ",(0,s.jsx)(t.code,{children:"mesh"}),"; it is not of the type that the plu-ts ",(0,s.jsx)(t.code,{children:"TxBuilder"})," expects."]}),"\n",(0,s.jsxs)(t.p,{children:["For this reason we can ",(0,s.jsx)(t.code,{children:"map"})," ",(0,s.jsx)(t.code,{children:"toPlutsUtxo"})," (defined in ",(0,s.jsx)(t.code,{children:"src/offchain/mesh-utils.ts"}),") over the result of the ",(0,s.jsx)(t.code,{children:"getUtxos"})," call;\nso that ",(0,s.jsx)(t.code,{children:"myUTxOs"})," is defined as:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'const myUTxOs = (await wallet.getUtxos()).map(toPlutsUtxo);\n\nif (myUTxOs.length === 0) {\n  throw new Error("have you requested founds from the faucet?");\n}\n'})}),"\n",(0,s.jsxs)(t.admonition,{title:"get some funds",type:"tip",children:[(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.code,{children:"myUTxOs"})," happens to be empty (",(0,s.jsx)(t.code,{children:"length === 0"}),") that means that your wallet has nothing in it."]}),(0,s.jsxs)(t.p,{children:["If that is the case you can use the ",(0,s.jsx)(t.a,{href:"https://docs.cardano.org/cardano-testnet/tools/faucet",children:"Cardano Testnet Faucet"})," to get some testnet funds."]}),(0,s.jsxs)(t.p,{children:["Just be sure to select the ",(0,s.jsx)(t.strong,{children:"Preprod"})," testnet."]})]}),"\n",(0,s.jsxs)(t.admonition,{title:"return the test ADA",type:"caution",children:[(0,s.jsx)(t.p,{children:"Once you finish with your tADA make sure to return them to the faucet."}),(0,s.jsx)(t.p,{children:"tADA have no real world value but are still limited, and other developers will need them!"}),(0,s.jsx)(t.p,{children:"To return tADA to the faucet just send them to the following testnet address:"}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3"})})]}),"\n",(0,s.jsx)(t.h3,{id:"utxo",children:(0,s.jsx)(t.code,{children:"utxo"})}),"\n",(0,s.jsx)(t.p,{children:"With this transaction we want to send 10 ADA to the contract."}),"\n",(0,s.jsx)(t.p,{children:"So we search between the utxos we already have for one that has a little more than that (so that we can cover the transaction fees)."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'const utxo = myUTxOs.find(u => u.resolved.value.lovelaces > 15_000_000);\n\nif (utxo === undefined) {\n  throw new Error("not enough ada");\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"build-and-return-the-transaction",children:"Build and return the transaction"}),"\n",(0,s.jsx)(t.p,{children:"And with all this we have:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"An user utxo to use as input"}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"scriptTestnetAddr"})," (imported from ",(0,s.jsx)(t.code,{children:"contracts/helloPluts.ts"}),") which is the script address to use in the output"]}),"\n",(0,s.jsx)(t.li,{children:"The user public key hash that we'll use as output datum"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Which is all we need for our transaction;"}),"\n",(0,s.jsxs)(t.p,{children:["So we can build it using the ",(0,s.jsx)(t.code,{children:"txBuilder"})," we have:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"txBuilder.buildSync({\n  inputs: [{ utxo }],\n  outputs: [{ // output holding the founds that we'll spend later\n    address: scriptTestnetAddr,\n    // 10M lovelaces === 10 ADA\n    value: Value.lovelaces(10_000_000),\n    // remeber to include a datum\n    datum: new DataB(\n      // remember we set the datum to be the public key hash?\n      // we can extract it from the address as follows\n      myAddr.paymentCreds.hash.toBuffer()\n    )\n  }],\n  // send everything left back to us\n  changeAddress: myAddr\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["So that the final ",(0,s.jsx)(t.code,{children:"getLockTx"})," function should look like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/offchain/lockTx.ts"',children:'async function getLockTx(wallet: BrowserWallet, Blockfrost: BlockfrostPluts): Promise<Tx> {\n  // creates an address form the bech32 form\n  const myAddr = Address.fromString(\n    await wallet.getChangeAddress()\n  );\n\n  const txBuilder = await getTxBuilder(Blockfrost);\n  const myUTxOs = (await wallet.getUtxos()).map(toPlutsUtxo);\n\n  if (myUTxOs.length === 0) {\n    throw new Error("have you requested founds from the faucet?");\n  }\n\n  const utxo = myUTxOs.find(u => u.resolved.value.lovelaces > 15_000_000);\n\n  if (utxo === undefined) {\n    throw new Error("not enough ada");\n  }\n\n  return txBuilder.buildSync({\n    inputs: [{ utxo }],\n    outputs: [{ // output holding the founds that we\'ll spend later\n      address: scriptTestnetAddr,\n      // 10M lovelaces === 10 ADA\n      value: Value.lovelaces(10_000_000),\n      // remeber to include a datum\n      datum: new DataB(\n        // remember we set the datum to be the public key hash?\n        // we can extract it from the address as follows\n        myAddr.paymentCreds.hash.toBuffer()\n      )\n    }],\n    // send everything left back to us\n    changeAddress: myAddr\n  });\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"test-it-out",children:"Test it out"}),"\n",(0,s.jsxs)(t.p,{children:["With ",(0,s.jsx)(t.code,{children:"getLockTx"})," implemented the first button on the webpage should now work."]}),"\n",(0,s.jsx)(t.p,{children:"To test it out run"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"npm run dev\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And navigate to the specified url (eg. ",(0,s.jsx)(t.code,{children:"http://localhost:3000/"}),");"]}),"\n",(0,s.jsx)(t.p,{children:"Then connect your wallet."}),"\n",(0,s.jsxs)(t.p,{children:["And click on the ",(0,s.jsx)(t.code,{children:"Lock 10 tADA"})," button."]}),"\n",(0,s.jsx)(t.p,{children:"If everything works correctly you should be prompted to sign a transaction."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"sing transaction pop-up",src:n(69272).c+"",width:"1312",height:"645"})}),"\n",(0,s.jsx)(t.h2,{id:"unlock-the-funds",children:"Unlock the funds"}),"\n",(0,s.jsx)(t.p,{children:"Now that the smart contract has something to spend we can really test it out."}),"\n",(0,s.jsx)(t.p,{children:"In fact, our smart contract never ran so far."}),"\n",(0,s.jsx)(t.p,{children:'That is because Cardano smart contracts only run if funds needs to be spent (some call them "Spending Validators").'}),"\n",(0,s.jsx)(t.p,{children:"So now we are going to do exactly that, we are going to spend some (our) smart contract funds."}),"\n",(0,s.jsx)(t.p,{children:"The starting point is similar to before."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/offchain/getUnlockTx.ts"',children:"async function getUnlockTx(wallet: BrowserWallet, Blockfrost: BlockfrostPluts): Promise<Tx> {\n  throw new Error(\"'unlockTx' logic not implemented\");   \n}\n"})}),"\n",(0,s.jsxs)(t.h3,{id:"txbuilder-and-myutxos",children:[(0,s.jsx)(t.code,{children:"txBuilder"})," and ",(0,s.jsx)(t.code,{children:"myUTxOs"})]}),"\n",(0,s.jsx)(t.p,{children:"Transaction builder and utxos for the transaction."}),"\n",(0,s.jsx)(t.p,{children:"The steps are the same:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const txBuilder = await getTxBuilder();\nconst myUTxOs = (await wallet.getUtxos()).map(toPlutsUtxo);\n"})}),"\n",(0,s.jsxs)(t.h3,{id:"myaddrs-and-myaddr",children:[(0,s.jsx)(t.code,{children:"myAddrs"})," and ",(0,s.jsx)(t.code,{children:"myAddr"})]}),"\n",(0,s.jsxs)(t.p,{children:["Before we got the user address by calling ",(0,s.jsx)(t.code,{children:"wallet.getChangeAddress"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"This returns a single address of the contract. But wallet might have many;\nand from the moment that we are not really sure of which one we'll get, this time we'll select it manually."}),"\n",(0,s.jsx)(t.p,{children:"To get all the address of a wallet we can call"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"await wallet.getUsedAddresses()\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Just like before the method returns strings; so we'll need to call ",(0,s.jsx)(t.code,{children:"Address.fromString"})," for each of them."]}),"\n",(0,s.jsx)(t.p,{children:"This way we can get all the wallet addresses as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const myAddrs = (await wallet.getUsedAddresses()).map(Address.fromString);\n"})}),"\n",(0,s.jsx)(t.p,{children:"From these we'll decide which one will be used in the next step."}),"\n",(0,s.jsx)(t.p,{children:"For now lets just declare a variable for it."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"let myAddr!: Address;\n"})}),"\n",(0,s.jsx)(t.h3,{id:"get-the-scripts-utxos",children:"Get the script's utxos"}),"\n",(0,s.jsx)(t.p,{children:"Script utxos are a bit trickier... scripts don't have wallets!"}),"\n",(0,s.jsx)(t.p,{children:"So to retrieve the script's utxos we'll rely on Blockfrost; the code to query them is:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"await Blockfrost.addressUtxos(scriptTestnetAddr)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Where ",(0,s.jsx)(t.code,{children:"scriptTestnetAddr"})," is imported from ",(0,s.jsx)(t.code,{children:"contracts/helloPluts.ts"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"But a script might (and will) have multiple utxos... how do we know which one is our?"}),"\n",(0,s.jsx)(t.p,{children:"For that we'll search between them using the following function"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const utxoToSpend = (await Blockfrost.addressUtxos(scriptTestnetAddr)).find(utxo => {\n  const datum = utxo.resolved.datum;\n\n  // datum is inline and is only bytes\n  if (isData(datum) && datum instanceof DataB) {\n    const pkh = datum.bytes.toBuffer();\n\n    // search if it corresponds to one of my public keys\n    const myPkhIdx = myAddrs.findIndex(\n      addr => uint8ArrayEq(pkh, addr.paymentCreds.hash.toBuffer())\n    );\n\n    // not a pkh of mine; not an utxo I can unlock\n    if (myPkhIdx < 0) return false;\n\n    // else found my locked utxo\n    myAddr = myAddrs[myPkhIdx];\n\n    return true;\n  }\n\n  return false;\n});\n"})}),"\n",(0,s.jsx)(t.p,{children:"Given an utxo we first need to check that it has an inline datum and that the datum is just made of bytes."}),"\n",(0,s.jsx)(t.p,{children:"Once we know the datum is in the correct format we extract the setted public key hash that represents that utxo owner:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const pkh = datum.bytes.toBuffer();\n"})}),"\n",(0,s.jsx)(t.p,{children:"And finally we check for the owner to be equal to any of the addresses in control of the wallet;\nif any address matches the we found the address to be used and the utxo to be spent; otherwise we check another utxo."}),"\n",(0,s.jsxs)(t.p,{children:["After the filter call ",(0,s.jsx)(t.code,{children:"myAddr"})," will then be defined."]}),"\n",(0,s.jsx)(t.h3,{id:"build-the-transaction",children:"Build the transaction"}),"\n",(0,s.jsx)(t.p,{children:"Now that we have everything we need; we can build the unlocking transaction:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'txBuilder.buildSync({\n  inputs: [{\n    utxo: utxoToSpend as any,\n    // we must include the utxo that holds our script\n    inputScript: {\n      script,\n      datum: "inline", // the datum is present already on `utxoToSpend`\n      redeemer: new DataB(fromAscii("Hello plu-ts")) // be polite\n    }\n  }],\n  requiredSigners: [myAddr.paymentCreds.hash],\n  // make sure to include collateral when using contracts\n  collaterals: [myUTxOs[0]],\n  // send everything back to us\n  changeAddress: myAddr\n});\n'})}),"\n",(0,s.jsx)(t.p,{children:"This time the transaction is a bit more complicated so let's check what's new."}),"\n",(0,s.jsx)(t.p,{children:"First of all the input now comes from a script! For this reason we have to include the script in alongside the utxo to be spent for the script to validate it."}),"\n",(0,s.jsxs)(t.p,{children:["This is done trough the ",(0,s.jsx)(t.code,{children:"inputScript"})," option:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'inputScript: {\n  script,\n  datum: "inline", // the datum is present already on `utxoToSpend`\n  redeemer: new DataB(fromAscii("Hello plu-ts")) // be polite\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"script"})," is the one imported from ",(0,s.jsx)(t.code,{children:"contracts/helloPluts.ts"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"datum"})," is set to be ",(0,s.jsx)(t.code,{children:'"inline"'})," which means that the datum is already present on the UTxO being spent."]}),"\n",(0,s.jsxs)(t.p,{children:["Finally ",(0,s.jsx)(t.code,{children:"redeemer"})," is used to pass the redeemer to call the contract with."]}),"\n",(0,s.jsxs)(t.admonition,{title:"redeemer",type:"tip",children:[(0,s.jsx)(t.p,{children:"Unlike the datum, the redeemer is used to pass data to the script at the moment of calling it."}),(0,s.jsx)(t.p,{children:"This can be used as a way to comunicate between the user and the contract"})]}),"\n",(0,s.jsxs)(t.p,{children:["The other important part of the transaction is the ",(0,s.jsx)(t.code,{children:"requiredSigners"})," option."]}),"\n",(0,s.jsxs)(t.p,{children:["Here we have to specify the our public key hash so that it can be included in the ",(0,s.jsx)(t.code,{children:"signatories"})," field of the context passed to the contract.\nIf we forget it the ",(0,s.jsx)(t.code,{children:"ctx.tx.signatories"})," value in our smart contract will be empty!"]}),"\n",(0,s.jsxs)(t.p,{children:["And finally, the third news is the ",(0,s.jsx)(t.code,{children:"collaterals"})," option; this can be any utxo we own as long as it contains only ADA;\nif it includes any other token it must be returned using the ",(0,s.jsx)(t.code,{children:"collateralReturn"})," option; but this is not our case."]}),"\n",(0,s.jsxs)(t.p,{children:["So our final ",(0,s.jsx)(t.code,{children:"getUnlockTx"})," function looks like this."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="src/offchain/unlockTx.ts"',children:'async function getUnlockTx(wallet: BrowserWallet, Blockfrost: BlockfrostPluts): Promise<Tx> {\n  const txBuilder = await getTxBuilder(Blockfrost);\n  const myAddrs = (await wallet.getUsedAddresses()).map(Address.fromString);\n  const myUTxOs = (await wallet.getUtxos()).map(toPlutsUtxo);\n\n  /**\n   * Wallets migh have multiple addresses;\n   * \n   * to understand which one we previously used to lock founds\n   * we\'ll get the address based on the utxo that keeps one of ours\n   * public key hash as datum\n  **/\n  let myAddr!: Address;\n\n  // only the onses with valid datum\n  const utxoToSpend = (await Blockfrost.addressUtxos(scriptTestnetAddr)).find(utxo => {\n    const datum = utxo.resolved.datum;\n\n    // datum is inline and is only bytes\n    if (isData(datum) && datum instanceof DataB) {\n      const pkh = datum.bytes.toBuffer();\n\n      // search if it corresponds to one of my public keys\n      const myPkhIdx = myAddrs.findIndex(\n        addr => uint8ArrayEq(pkh, addr.paymentCreds.hash.toBuffer())\n      );\n\n      // not a pkh of mine; not an utxo I can unlock\n      if (myPkhIdx < 0) return false;\n\n      // else found my locked utxo\n      myAddr = myAddrs[myPkhIdx];\n\n      return true;\n    }\n\n    return false;\n  });\n\n  if (utxoToSpend === undefined) {\n    throw new Error("uopsie, are you sure your tx had enough time to get to the blockchain?");\n  }\n\n  return txBuilder.buildSync({\n    inputs: [{\n      utxo: utxoToSpend as any,\n      // we must include the utxo that holds our script\n      inputScript: {\n        script,\n        datum: "inline", // the datum is present already on `utxoToSpend`\n        redeemer: new DataB(fromAscii("Hello plu-ts")) // be polite\n      }\n    }],\n    requiredSigners: [myAddr.paymentCreds.hash],\n    // make sure to include collateral when using contracts\n    collaterals: [myUTxOs[0]],\n    // send everything back to us\n    changeAddress: myAddr\n  });\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"test-the-contract",children:"Test the contract"}),"\n",(0,s.jsx)(t.p,{children:"Now our applicaiton is complete."}),"\n",(0,s.jsx)(t.p,{children:"We just need to test out the last feature introduced."}),"\n",(0,s.jsx)(t.p,{children:"Once again spin up the web page and this time let's click on the second button."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"unlock tx pop-up",src:n(24656).c+"",width:"1312",height:"645"})}),"\n",(0,s.jsxs)(t.admonition,{title:"smart contract determinism",type:"tip",children:[(0,s.jsx)(t.p,{children:"Did you know that smart contract on cardano are deterministic?"}),(0,s.jsx)(t.p,{children:"It means that when you run them with the same inputs you always get the same output."}),(0,s.jsxs)(t.p,{children:["For this reason the plu-ts ",(0,s.jsx)(t.code,{children:"TxBuilder"})," is able to pre-evaluate your transaction\nand will throw an error if the script fails!"]}),(0,s.jsx)(t.p,{children:"That means that if you are signing a transaction built wit plu-ts you can be sure there are no surprises!"})]}),"\n",(0,s.jsx)(t.p,{children:"Here is an example of a successful transaction:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://preprod.cardanoscan.io/transaction/3d04a8bb90c3d6edb765439f3ec370053b2904841648ba64281c0680a73226fa",children:"https://preprod.cardanoscan.io/transaction/3d04a8bb90c3d6edb765439f3ec370053b2904841648ba64281c0680a73226fa"})})]})}function h(e={}){const{wrapper:t}={...(0,r.M)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},87768:(e,t,n)=>{n.d(t,{c:()=>i});n(11504);var s=n(65456);const r={tabItem:"tabItem_Ymn6"};var o=n(17624);function i(e){let{children:t,hidden:n,className:i}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,s.c)(r.tabItem,i),hidden:n,children:t})}},61268:(e,t,n)=>{n.d(t,{c:()=>k});var s=n(11504),r=n(65456),o=n(53943),i=n(55592),l=n(95288),a=n(10632),c=n(27128),d=n(21148);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:r}}=e;return{value:t,label:n,attributes:s,default:r}}))}(n);return function(e){const t=(0,c.w)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function x(e){let{queryString:t=!1,groupId:n}=e;const r=(0,i.Uz)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,a._M)(o),(0,s.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=u(e),[i,a]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:o}))),[c,h]=x({queryString:n,groupId:r}),[m,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,d.IN)(n);return[r,(0,s.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),j=(()=>{const e=c??m;return p({value:e,tabValues:o})?e:null})();(0,l.c)((()=>{j&&a(j)}),[j]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);a(e),h(e),f(e)}),[h,f,o]),tabValues:o}}var f=n(93664);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=n(17624);function w(e){let{className:t,block:n,selectedValue:s,selectValue:i,tabValues:l}=e;const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.MV)(),d=e=>{const t=e.currentTarget,n=a.indexOf(t),r=l[n].value;r!==s&&(c(t),i(r))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=a.indexOf(e.currentTarget)+1;t=a[n]??a[0];break}case"ArrowLeft":{const n=a.indexOf(e.currentTarget)-1;t=a[n]??a[a.length-1];break}}t?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.c)("tabs",{"tabs--block":n},t),children:l.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>a.push(e),onKeyDown:h,onClick:d,...o,className:(0,r.c)("tabs__item",j.tabItem,o?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function y(e){let{lazy:t,children:n,selectedValue:r}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function b(e){const t=m(e);return(0,g.jsxs)("div",{className:(0,r.c)("tabs-container",j.tabList),children:[(0,g.jsx)(w,{...t,...e}),(0,g.jsx)(y,{...t,...e})]})}function k(e){const t=(0,f.c)();return(0,g.jsx)(b,{...e,children:h(e.children)},String(t))}},69272:(e,t,n)=>{n.d(t,{c:()=>s});const s=n.p+"assets/images/sign_lock_hello_world-0f9426fd1c6ee038f2026004508f9647.gif"},24656:(e,t,n)=>{n.d(t,{c:()=>s});const s=n.p+"assets/images/sign_unlock_hello_world-2f63bc751cf67e198a7d71af1ee795fc.gif"},4552:(e,t,n)=>{n.d(t,{I:()=>l,M:()=>i});var s=n(11504);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);