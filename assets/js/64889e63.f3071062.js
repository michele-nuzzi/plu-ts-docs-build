"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[8768],{53008:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=t(17624),s=t(4552);const o={sidebar_position:2},r="precursive",a={id:"onchain/Control Flow/precursive",title:"precursive",description:"The other thing we are missing to have a proper language is some way to repeat the execution of some code.",source:"@site/docs/onchain/Control Flow/precursive.mdx",sourceDirName:"onchain/Control Flow",slug:"/onchain/Control Flow/precursive",permalink:"/onchain/Control Flow/precursive",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/onchain/Control Flow/precursive.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"pmatch",permalink:"/onchain/Control Flow/pmatch"},next:{title:"Evaluation and testing",permalink:"/category/evaluation-and-testing"}},c={},l=[];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,s.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"precursive",children:(0,i.jsx)(n.code,{children:"precursive"})}),"\n",(0,i.jsx)(n.p,{children:"The other thing we are missing to have a proper language is some way to repeat the execution of some code."}),"\n",(0,i.jsx)(n.p,{children:"The functional paradigm doesn't really like things like the loops we have in Typescript but that is not a big deal, because we can use recursive functions instead."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Wait a second!"})}),"\n",(0,i.jsx)(n.p,{children:"Don't we need to reference the same function we are defining in order to make it recursive?"}),"\n",(0,i.jsx)(n.p,{children:"How do we do that if we need what we are defining while defining it?"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Turns out someone else already came up with a solution for that so that we don't have to."}),"\n",(0,i.jsxs)(n.p,{children:["That solution is the ",(0,i.jsx)(n.strong,{children:"Y combinator"})," (actually we'll use the ",(0,i.jsx)(n.em,{children:"Z combinator"})," but whatever)."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["We'll not go in the details on how it works, but if you are a curious one here's a great article that explains the ",(0,i.jsx)(n.a,{href:"https://medium.com/swlh/y-and-z-combinators-in-javascript-lambda-calculus-with-real-code-31f25be934ec",children:"Y combinator in javascript terms"})]})}),"\n",(0,i.jsx)(n.p,{children:"All you need to know is that it allows functions to have themselves as parameters, and this solves everything!"}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.code,{children:"plu-ts"})," there is a special typescript function that makes ",(0,i.jsx)(n.code,{children:"plu-ts"})," functions recursive, and it's named, you guessed it, ",(0,i.jsx)(n.code,{children:"precursive"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["All ",(0,i.jsx)(n.code,{children:"precursive"})," requires to make a ",(0,i.jsx)(n.code,{children:"plu-ts"})," function recursive is that we pass the function as the first parameter, and then we can do whatever we want with it."]}),"\n",(0,i.jsxs)(n.p,{children:["So let's try to define a ",(0,i.jsx)(n.code,{children:"plu-ts"})," function that calculates the factorial of a positive number:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const pfactorial = precursive(\n    pfn([\n        // remember that the first argument is the function itself?\n        // for this reason as first type we specify\n        // what will be the final type of the function\n        // because what we have here IS the function itself\n        // highlight-next-line\n        lam( int, int ),\n        int\n    ],  int)\n    (( self, n ) =>\n        pif( int ).$(\n            n.ltEq( 1 )\n        )\n        .then( 1 )\n        .else(\n            // highlight-start\n            // here we are applying this same function\n            // this is the equivalent of writing \n            // `pfactorial.$( n.sub( 1 ) )`\n            self.$( n.sub( 1 ) )\n            // highlight-end\n            .mult( n )\n        )\n    )\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now we can use ",(0,i.jsx)(n.code,{children:"pfactorial"})," just like a normal function; this is because ",(0,i.jsx)(n.code,{children:"precursive"})," takes care of passing the first argument, so that the actual type of ",(0,i.jsx)(n.code,{children:"pfactorial"})," is just ",(0,i.jsx)(n.code,{children:"lam( int, int )"})]}),"\n",(0,i.jsxs)(n.p,{children:["The next step is to learn how to ",(0,i.jsx)(n.a,{href:"../Evaluating%20and%20testing/evaluation",children:"evaluate expressions"})," so that we can be sure that ",(0,i.jsx)(n.code,{children:"pfactorial"})," is working as we expect."]})]})}function u(e={}){const{wrapper:n}={...(0,s.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},4552:(e,n,t)=>{t.d(n,{I:()=>a,M:()=>r});var i=t(11504);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);