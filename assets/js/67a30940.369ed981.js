"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[8858],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),m=s(n),d=i,f=m["".concat(l,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(f,r(r({ref:t},u),{},{components:n})):a.createElement(f,r({ref:t},u))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[m]="string"==typeof e?e:i,r[1]=p;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2656:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>p,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:1},r="plam and pfn",p={unversionedId:"onchain/Values/Functions/plam_and_pfn",id:"onchain/Values/Functions/plam_and_pfn",title:"plam and pfn",description:"Functions can be transformed from the Typescript world to the plu-ts one just like any other value.",source:"@site/docs/onchain/Values/Functions/plam_and_pfn.mdx",sourceDirName:"onchain/Values/Functions",slug:"/onchain/Values/Functions/plam_and_pfn",permalink:"/docs/onchain/Values/Functions/plam_and_pfn",draft:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts/tree/main/packages/create-docusaurus/templates/shared/docs/onchain/Values/Functions/plam_and_pfn.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Functions",permalink:"/docs/category/functions"},next:{title:"Function application",permalink:"/docs/onchain/Values/Functions/Function_appliaciton"}},l={},s=[{value:"<code>plam</code>",id:"plam",level:2},{value:"<code>pfn</code>",id:"pfn",level:2}],u={toc:s},m="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"plam-and-pfn"},(0,i.kt)("inlineCode",{parentName:"h1"},"plam")," and ",(0,i.kt)("inlineCode",{parentName:"h1"},"pfn")),(0,i.kt)("p",null,"Functions can be transformed from the Typescript world to the ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," one just like any other value."),(0,i.kt)("p",null,"This can be done with two functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"plam")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pfn"))),(0,i.kt)("h2",{id:"plam"},(0,i.kt)("inlineCode",{parentName:"h2"},"plam")),(0,i.kt)("p",null,"Just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"lam")," type, ",(0,i.kt)("inlineCode",{parentName:"p"},"plam")," only works for functions with one input; don't worry, ",(0,i.kt)("inlineCode",{parentName:"p"},"pfn")," is more powerful, but ",(0,i.kt)("inlineCode",{parentName:"p"},"plam")," will help us understand the basics."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"plam")," signature is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function plam<A extends TermType, B extends TermType >( inputType: A, outputType: B )\n    : ( termFunc : ( input: Term<ToPType<A>> ) => Term<ToPType<B>> ) => Term<PLam<ToPType<A>,ToPType<B>>>\n")),(0,i.kt)("p",null,"If this seems familiar it's because it works on the same principle of ",(0,i.kt)("inlineCode",{parentName:"p"},"pList")," we saw in the explanation of ",(0,i.kt)("a",{parentName:"p",href:"../Simple%20Values"},"simple values"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"plam")," first requires us to specify the ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," types we are working with and it gives back a function ad-hoc for those types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const makeLambdaFromIntToBool\n    : ( tellMeHow: ( int: Term<PInt> ) => Term<PBool> ) => Term<PLam<PInt, PBool>> = \n    plam( int, bool )\n")),(0,i.kt)("p",null,'The function we get back expects a typescript function as input that describe how to "transform" the input to the output.'),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"tellMeHow"),' function should return a Term; we need some way to "build" a new term.'),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," you ",(0,i.kt)("em",{parentName:"p"},"never")," need to write anything like ",(0,i.kt)("inlineCode",{parentName:"p"},"new Term(...)"),"; rather you use ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," functions to build new ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," terms."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("em",{parentName:"p"},"Wait what?")," Aren't ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," functions also Terms? How do I build new Terms if I need other Terms to build new Terms?")),(0,i.kt)("p",null,"Fortunately for us there are some ",(0,i.kt)("a",{parentName:"p",href:"./builtins"},"builtin functions")," that form the fundamentals of the language."),(0,i.kt)("p",null,"We can use these to describe the body of our lambda."),(0,i.kt)("p",null,"these builtins will often be aviable directly on our ",(0,i.kt)("inlineCode",{parentName:"p"},"Term"),", as in the example below"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const pintIsZero = makeLambdaFromIntToBool(\n    someInt => peqInt.$( someInt ).$( 0 )\n);\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"p<Stuff>")," convention"),(0,i.kt)("p",{parentName:"admonition"},"is convention to name ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts"),' functions starting with a lower case "p"; indicating that we are in the ',(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," world and not the typescript one")),(0,i.kt)("p",null,"Here we are using the ",(0,i.kt)("inlineCode",{parentName:"p"},"peqInt")," builtin function; the ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," method is a short form for the ",(0,i.kt)("a",{parentName:"p",href:"./Function_appliaciton"},(0,i.kt)("inlineCode",{parentName:"a"},"papp")," function")," and is how we pass arguments to a ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," function (we'll cover function application in the very next section)."),(0,i.kt)("p",null,"What matters for now is that we succesfully transformed an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," into a ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," using only ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts"),"; and we now have a new function that we can re-use when needed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"pintIsZero.$( pInt(42) ) // this is a Term<PBool> equivalent to `pBool( false )`\n")),(0,i.kt)("h2",{id:"pfn"},(0,i.kt)("inlineCode",{parentName:"h2"},"pfn")),(0,i.kt)("p",null,"Now that we know how the ",(0,i.kt)("inlineCode",{parentName:"p"},"plam")," machinery works let's look at the more useful ",(0,i.kt)("inlineCode",{parentName:"p"},"pfn"),"."),(0,i.kt)("p",null,"The signature (a bit simplified; this is not Typescript) is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function pfn<InputsTypes extends [ TermType, ...TermType[] ], OutputType extends TermType>( inputsTypes: InputsTypes, outputType: OutputType )\n    : ( termFunction: ( ...inptus: PInputs ) => POutput ) => \n        Term<PFn<PInputs, POutput>>\n")),(0,i.kt)("p",null,"and with the exception of an array of types as input rather than a single type we see it is doing the exact same thing as ",(0,i.kt)("inlineCode",{parentName:"p"},"plam")," but with more inputs."),(0,i.kt)("p",null,"So if we want a function that builds a ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," level function for us of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> int -> list( int )")," we just write"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const makeListFromTwoInts = pfn( [ int, int ], list( int ) );\n")),(0,i.kt)("p",null,"and just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"plam")," case, we use the function we just got to build a ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," one."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const pTwoIntegersList = makeListFromTwoInts(\n    ( int1, int2 ) => pList([ int1, int2 ])\n);\n")))}c.isMDXComponent=!0}}]);