"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[4844],{66532:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>r});var s=t(17624),a=t(4552);const i={sidebar_position:3},o="Aliases",l={id:"onchain/Values/aliases",title:"Aliases",description:"The pAlias function allows you to create a new type alias that inherits all the properties and methods of an existing type, while also providing the flexibility to define custom methods specific to the alias.",source:"@site/docs/onchain/Values/aliases.mdx",sourceDirName:"onchain/Values",slug:"/onchain/Values/aliases",permalink:"/onchain/Values/aliases",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/onchain/Values/aliases.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"builtins",permalink:"/onchain/Values/Functions/builtins"},next:{title:"Structs",permalink:"/category/structs"}},c={},r=[{value:"What&#39;s the <code>plu-ts</code> type of my alias?",id:"whats-the-plu-ts-type-of-my-alias",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"aliases",children:"Aliases"}),"\n",(0,s.jsx)(n.p,{children:"The pAlias function allows you to create a new type alias that inherits all the properties and methods of an existing type, while also providing the flexibility to define custom methods specific to the alias.\nThis is particularly useful when you want to create a type that behaves like an existing type but has additional functionality or a more descriptive name."}),"\n",(0,s.jsx)(n.p,{children:"In some cases it might be useful to define aliases for already existing types."}),"\n",(0,s.jsx)(n.p,{children:"In the current implementation, aliases do not really have any specific advantage other than making your code more expressive. Currently, aliases can be used everywhere the aliased type is accepted and vice-versa."}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Generally speaking you may want to use aliases to define a ",(0,s.jsx)(n.em,{children:"subset"})," of values that are meant to have a specific meaning"]}),(0,s.jsx)(n.p,{children:"Example: you might need a type that describes the name of a person; every name is a string; but not every string is a name."}),(0,s.jsxs)(n.p,{children:["To make clear the distinction you define an alias of the ",(0,s.jsx)(n.code,{children:"string"})," type to be the ",(0,s.jsx)(n.code,{children:"Name"})," type"]})]}),"\n",(0,s.jsxs)(n.p,{children:["We define new aliases using the ",(0,s.jsx)(n.code,{children:"palias"})," ts function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const Age = palias( int );\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now we have a new type to specifically represent ages."}),"\n",(0,s.jsxs)(n.p,{children:["To get a term of the aliased type you can use the ",(0,s.jsx)(n.code,{children:"from"})," static method of the class you got from calling ",(0,s.jsx)(n.code,{children:"palias"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const someAge: Term<typeof Age> = Age.from( pInt(18) ); \n"})}),"\n",(0,s.jsx)(n.p,{children:"To enhance the alias with specific custom methods, we can:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const Age = palias(int, "Age", {\n    inDogYears: pfn([int], int)(age => age.mul(7)),\n    nextBirthday: pfn([int], int)(age => age.add(1))\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"which can be used as,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const myAge = Age(20);\n\nconst dogYears = myAge.inDogYears(); // 140\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["In a future version aliases will be able to add constraints over the type the are alias of\nas an example whe might want to force every ",(0,s.jsx)(n.code,{children:"Age"})," to be non-negative, since a negative age doesn't really make sense"]}),(0,s.jsxs)(n.p,{children:["When an alias will be constrained ",(0,s.jsx)(n.code,{children:"plu-ts"})," will check for the constraints to be met each time a term with an alias is constructed\n",(0,s.jsx)(n.strong,{children:"and will fail the computation if the constraints are not met"})]})]}),"\n",(0,s.jsxs)(n.h2,{id:"whats-the-plu-ts-type-of-my-alias",children:["What's the ",(0,s.jsx)(n.code,{children:"plu-ts"})," type of my alias?"]}),"\n",(0,s.jsxs)(n.p,{children:["As explained in the ",(0,s.jsx)(n.a,{href:"../Types",children:"types"})," section, aliases and structs have different ",(0,s.jsx)(n.code,{children:"plu-ts"})," level types. To access them we need to use the ",(0,s.jsx)(n.code,{children:"type"})," static method defined in the Alias class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const agePlutsType = Age.type;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["So if we want to define a function that accepts an ",(0,s.jsx)(n.code,{children:"Age"})," as input we would write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const pisAdult = plam( Age.type, bool )\n( age => age.gtEq( 18 ) );\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Remember partial function application",type:"tip",children:[(0,s.jsxs)(n.p,{children:["Or the slightly more efficient version, based on ",(0,s.jsx)(n.a,{href:"./Functions/partial_function_app",children:"partial function application"}),":"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const pisAdult = plessThanEqual.$( 18 )\n"})})]})]})}function h(e={}){const{wrapper:n}={...(0,a.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},4552:(e,n,t)=>{t.d(n,{I:()=>l,M:()=>o});var s=t(11504);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);