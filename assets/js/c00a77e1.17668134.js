"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[9424],{55292:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>x,frontMatter:()=>i,metadata:()=>c,toc:()=>o});var t=r(17624),s=r(4552);const i={sidebar_position:2},d="TermBS",c={id:"onchain/stdlib/TermBS",title:"TermBS",description:"type definition:",source:"@site/docs/onchain/stdlib/TermBS.mdx",sourceDirName:"onchain/stdlib",slug:"/onchain/stdlib/TermBS",permalink:"/onchain/stdlib/TermBS",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/onchain/stdlib/TermBS.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"TermBool",permalink:"/onchain/stdlib/TermBool"},next:{title:"TermStr",permalink:"/onchain/stdlib/TermStr"}},l={},o=[{value:"<code>length</code>",id:"length",level:2},{value:"<code>utf8Decoded</code>",id:"utf8decoded",level:2},{value:"<code>concat</code>",id:"concat",level:2},{value:"<code>prepend</code>",id:"prepend",level:2},{value:"<code>subByteString</code>",id:"subbytestring",level:2},{value:"<code>slice</code>",id:"slice",level:2},{value:"<code>at</code>",id:"at",level:2},{value:"<code>eq</code>",id:"eq",level:2},{value:"<code>lt</code>",id:"lt",level:2},{value:"<code>ltEq</code>",id:"lteq",level:2},{value:"<code>gt</code>",id:"gt",level:2},{value:"<code>gtEq</code>",id:"gteq",level:2}];function h(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,s.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"termbs",children:(0,t.jsx)(n.code,{children:"TermBS"})}),"\n",(0,t.jsx)(n.p,{children:"type definition:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"type TermBS = Term<PByteString> & {\n\n    readonly length: TermInt\n    \n    readonly utf8Decoded: TermStr\n    \n    readonly concatTerm: TermFn<[PByteString], PByteString>\n    readonly concat: ( other: Term<PByteString>) => TermBS\n\n    readonly prependTerm: TermFn<[PInt], PByteString>\n    readonly prepend: ( byte: Term<PInt> ) => TermBS\n\n    readonly subByteStringTerm: TermFn<[PInt, PInt], PByteString>\n    readonly subByteString: ( fromInclusive: Term<PInt>, ofLength: Term<PInt> ) => TermBS\n    \n    readonly sliceTerm: TermFn<[PInt, PInt], PByteString>\n    readonly slice:     ( fromInclusive: Term<PInt>, toExclusive: Term<PInt> ) => TermBS\n    \n    readonly atTerm:    TermFn<[PInt], PInt>\n    readonly at:        ( index: Term<PInt> ) => TermInt\n\n\n    readonly eqTerm:    TermFn<[PByteString], PBool>\n    readonly eq:        ( other: Term<PByteString> ) => TermBool\n\n    readonly ltTerm:    TermFn<[PByteString], PBool>\n    readonly lt:        ( other: Term<PByteString> ) => TermBool\n\n    readonly ltEqTerm:  TermFn<[PByteString], PBool>\n    readonly ltEq:      ( other: Term<PByteString> ) => TermBool\n\n    readonly gtTerm:    TermFn<[PByteString], PBool>\n    readonly gt:        ( other: Term<PByteString> ) => TermBool\n\n    readonly gtEqTerm:  TermFn<[PByteString], PBool>\n    readonly gtEq:      ( other: Term<PByteString> ) => TermBool\n\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"length",children:(0,t.jsx)(n.code,{children:"length"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"length"})}),(0,t.jsxs)(n.p,{children:["returns ",(0,t.jsx)(n.code,{children:"TermInt"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"plengthBs.$( term )\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"utf8decoded",children:(0,t.jsx)(n.code,{children:"utf8Decoded"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"utf8Decoded"})}),(0,t.jsxs)(n.p,{children:["returns ",(0,t.jsx)(n.code,{children:"TermStr"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"pdecodeUtf8.$( term )\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"concat",children:(0,t.jsx)(n.code,{children:"concat"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"concat"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"other"})," type: ",(0,t.jsx)(n.code,{children:"Term<PByteString>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBS"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"pappendBs.$( term ).$( other )\n"})})]}),"\n",(0,t.jsx)(n.p,{children:"concatenates the bytestring on which the method is defined on with the one passed as argument and returns a new bytestring as result of the operation"}),"\n",(0,t.jsx)(n.h2,{id:"prepend",children:(0,t.jsx)(n.code,{children:"prepend"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"prepend"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"byte"})," type: ",(0,t.jsx)(n.code,{children:"Term<PInt>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBS"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"pconsBs.$( byte ).$( term )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["expects the ",(0,t.jsx)(n.code,{children:"byte"})," argument to be an integer in the range ",(0,t.jsx)(n.code,{children:"0 <= byte <= 255"})]}),"\n",(0,t.jsx)(n.p,{children:"adds a single byte at the start of the term the method is defined on and returns a new bytestring as result."}),"\n",(0,t.jsx)(n.h2,{id:"subbytestring",children:(0,t.jsx)(n.code,{children:"subByteString"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"subByteString"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"fromInclusive"})," type: ",(0,t.jsx)(n.code,{children:"Term<PInt>"})]}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"ofLength"})," type: ",(0,t.jsx)(n.code,{children:"Term<PInt>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBS"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"psliceBs.$( fromInclusive ).$( ofLength ).$( term )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["takes ",(0,t.jsx)(n.code,{children:"fromInclusive"})," as index of the first byte to include in the result and the expected length as ",(0,t.jsx)(n.code,{children:"ofLength"})," as second parameter."]}),"\n",(0,t.jsxs)(n.p,{children:["returns ",(0,t.jsx)(n.code,{children:"ofLength"})," bytes starting from the one at index ",(0,t.jsx)(n.code,{children:"fromInclusive"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["somewhat more efficient than ",(0,t.jsx)(n.code,{children:"slice"})," as it maps directly to the builtin ",(0,t.jsx)(n.code,{children:"psliceBs"})," function."]}),"\n",(0,t.jsx)(n.h2,{id:"slice",children:(0,t.jsx)(n.code,{children:"slice"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"slice"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"fromInclusive"})," type: ",(0,t.jsx)(n.code,{children:"Term<PInt>"})]}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"toExclusive"})," type: ",(0,t.jsx)(n.code,{children:"Term<PInt>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBS"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"psliceBs.$( fromInclusive ).$( psub.$( toExclusive ).$( fromInclusive ) ).$( term )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["takes ",(0,t.jsx)(n.code,{children:"fromInclusive"})," as index of the first byte to include in the result\nand ",(0,t.jsx)(n.code,{children:"toExclusive"})," as the index of the first byte to exclude"]}),"\n",(0,t.jsx)(n.p,{children:"returns the bytes specified in the range"}),"\n",(0,t.jsx)(n.h2,{id:"at",children:(0,t.jsx)(n.code,{children:"at"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"at"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"index"})," type: ",(0,t.jsx)(n.code,{children:"Term<PInt>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermInt"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"pindexBs.$( term ).$( index )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["returns an integer in range ",(0,t.jsx)(n.code,{children:"0 <= byte <= 255"})," representing the byte at position ",(0,t.jsx)(n.code,{children:"index"})]}),"\n",(0,t.jsx)(n.h2,{id:"eq",children:(0,t.jsx)(n.code,{children:"eq"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"eq"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"other"})," type: ",(0,t.jsx)(n.code,{children:"Term<PByteString>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBool"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"peqBs.$( term ).$( other )\n"})})]}),"\n",(0,t.jsx)(n.p,{children:"bytestring equality"}),"\n",(0,t.jsx)(n.h2,{id:"lt",children:(0,t.jsx)(n.code,{children:"lt"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"lt"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"other"})," type: ",(0,t.jsx)(n.code,{children:"Term<PByteString>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBool"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"plessBs.$( term ).$( other )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["returns ",(0,t.jsx)(n.code,{children:"pBool( true )"})," if ",(0,t.jsx)(n.code,{children:"term"})," is strictly less than ",(0,t.jsx)(n.code,{children:"other"}),"; ",(0,t.jsx)(n.code,{children:"pBool( false )"})," otherwise"]}),"\n",(0,t.jsxs)(n.admonition,{title:"bytestrings order",type:"tip",children:[(0,t.jsxs)(n.p,{children:["bytestrings are ordered ",(0,t.jsx)(n.em,{children:"lexicographically"})]}),(0,t.jsx)(n.p,{children:"meaning that two strings are compared byte by byte"}),(0,t.jsx)(n.p,{children:"if the the byte of the first bytestring is less than the byte of the second; the first is considered less;"}),(0,t.jsx)(n.p,{children:"if it the two bytes are equal it checks the next byte"}),(0,t.jsx)(n.p,{children:"if the second is less than the first; the second is considered less;"})]}),"\n",(0,t.jsx)(n.h2,{id:"lteq",children:(0,t.jsx)(n.code,{children:"ltEq"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"ltEq"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"other"})," type: ",(0,t.jsx)(n.code,{children:"Term<PByteString>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBool"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"plessEqBs.$( term ).$( other )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["returns ",(0,t.jsx)(n.code,{children:"pBool( true )"})," if ",(0,t.jsx)(n.code,{children:"term"})," is less or equal than ",(0,t.jsx)(n.code,{children:"other"}),"; ",(0,t.jsx)(n.code,{children:"pBool( false )"})," otherwise"]}),"\n",(0,t.jsx)(n.h2,{id:"gt",children:(0,t.jsx)(n.code,{children:"gt"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"gt"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"other"})," type: ",(0,t.jsx)(n.code,{children:"Term<PByteString>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBool"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"pgreaterBS.$( term ).$( other )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["returns ",(0,t.jsx)(n.code,{children:"pBool( true )"})," if ",(0,t.jsx)(n.code,{children:"term"})," is strictly greater than ",(0,t.jsx)(n.code,{children:"other"}),"; ",(0,t.jsx)(n.code,{children:"pBool( false )"})," otherwise"]}),"\n",(0,t.jsx)(n.h2,{id:"gteq",children:(0,t.jsx)(n.code,{children:"gtEq"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"gtEq"})}),(0,t.jsxs)(n.p,{children:["parameter: ",(0,t.jsx)(n.code,{children:"other"})," type: ",(0,t.jsx)(n.code,{children:"Term<PByteString>"})]}),(0,t.jsxs)(n.p,{children:["returns: ",(0,t.jsx)(n.code,{children:"TermBool"})]}),(0,t.jsx)(n.p,{children:"equivalent expression:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"pgreaterEqBS.$( term ).$( other )\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["returns ",(0,t.jsx)(n.code,{children:"pBool( true )"})," if ",(0,t.jsx)(n.code,{children:"term"})," is greater or equal than ",(0,t.jsx)(n.code,{children:"other"}),"; ",(0,t.jsx)(n.code,{children:"pBool( false )"})," otherwise"]})]})}function x(e={}){const{wrapper:n}={...(0,s.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},4552:(e,n,r)=>{r.d(n,{I:()=>c,M:()=>d});var t=r(11504);const s={},i=t.createContext(s);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);