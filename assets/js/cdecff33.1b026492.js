"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[6556],{36956:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var s=t(17624),i=t(4552);const o={sidebar_position:2},r="pforce and pdelay",a={id:"onchain/Optimizations/pforce and pdelay",title:"pforce and pdelay",description:"plet and phoist are the two main tools to use when focusing on optimizations;",source:"@site/docs/onchain/Optimizations/pforce and pdelay.mdx",sourceDirName:"onchain/Optimizations",slug:"/onchain/Optimizations/pforce and pdelay",permalink:"/onchain/Optimizations/pforce and pdelay",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/onchain/Optimizations/pforce and pdelay.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"phoist",permalink:"/onchain/Optimizations/phoist"},next:{title:"stdlib",permalink:"/category/stdlib"}},c={},d=[];function l(e){const n={code:"code",em:"em",h1:"h1",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"pforce-and-pdelay",children:[(0,s.jsx)(n.code,{children:"pforce"})," and ",(0,s.jsx)(n.code,{children:"pdelay"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"plet"})," and ",(0,s.jsx)(n.code,{children:"phoist"})," are the two main tools to use when focusing on optimizations;"]}),"\n",(0,s.jsx)(n.p,{children:"this is because they significantly reduce both script size and cost of execution."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"pforce"})," and ",(0,s.jsx)(n.code,{children:"pdelay"})," do slightly increase the size of a script but when used properly they can save you quite a bit on execution costs."]}),"\n",(0,s.jsxs)(n.p,{children:["As we know, ",(0,s.jsx)(n.code,{children:"plu-ts"})," is strictly evaluated, meaning that arguments are evaluated before being passed to a function."]}),"\n",(0,s.jsxs)(n.p,{children:["We can opt out of this behaviour using ",(0,s.jsx)(n.code,{children:"pdelay"})," which wraps a term of any type in a ",(0,s.jsx)(n.code,{children:"delayed"})," type so a term of type ",(0,s.jsx)(n.code,{children:"int"})," becomes ",(0,s.jsx)(n.code,{children:"delayed( int )"})," if passed to ",(0,s.jsx)(n.code,{children:"pdelay"}),". A ",(0,s.jsx)(n.code,{children:"delayed"})," type can be unwrapped only using ",(0,s.jsx)(n.code,{children:"pforce"}),"; that finally executes the term."]}),"\n",(0,s.jsx)(n.p,{children:"There are two main reasons for why we would want to do this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"delaying the execution of some term we might not need at all"}),"\n",(0,s.jsx)(n.li,{children:"prevent to raise unwanted errors"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["One example of the use of ",(0,s.jsx)(n.code,{children:"pforce"})," and ",(0,s.jsx)(n.code,{children:"pdelay"})," is the ",(0,s.jsx)(n.code,{children:"pif"})," function."]}),"\n",(0,s.jsxs)(n.p,{children:["In fact, the base ",(0,s.jsx)(n.em,{children:"if then else"})," function is ",(0,s.jsx)(n.code,{children:"pstrictIf"}),", however when we use an ",(0,s.jsx)(n.em,{children:"if then else"})," statement we only need one of the two arguments to be actually evaluated."]}),"\n",(0,s.jsxs)(n.p,{children:["So when we call ",(0,s.jsx)(n.code,{children:"pif"}),", it is just as if we were doing something like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"pforce(\n    pstrictIf( delayed( returnType ) )\n    .$( myCondtion )\n    .$(\n        pdelay( caseTrue )\n    )\n    .$(\n        pdelay( caseFalse )\n    )\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"so that we only evaluate what we need."}),"\n",(0,s.jsx)(n.p,{children:"Not only that, but if one of the two branches throws an error but we don't need it, everything goes through smoothly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"pforce(\n    pstrictIf( delayed( int ) )\n    .$( true )\n    .$(\n        pdelay( pInt( 42 ) )\n    )\n    .$(\n        pdelay( perror( int ) )\n    )\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, everything is ok. If instead we just used the plain ",(0,s.jsx)(n.code,{children:"pstrictIf"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"    pstrictIf( int )\n    .$( pBool( true ) )\n    .$( pInt( 42 ) )\n    // highlight-error\n    .$( perror( int ) ) // KABOOM !!!\n"})}),"\n",(0,s.jsxs)(n.p,{children:["this results in an error, because the error is evaluated ",(0,s.jsx)(n.em,{children:"before"})," being passed as argument."]})]})}function p(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},4552:(e,n,t)=>{t.d(n,{I:()=>a,M:()=>r});var s=t(11504);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);