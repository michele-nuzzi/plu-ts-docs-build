"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[6144],{17092:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>o});var i=s(17624),r=s(4552);const l={sidebar_position:5},d="TermList<PElemsType>",t={id:"onchain/stdlib/TermList",title:"TermList<PElemsType>",description:"type definition:",source:"@site/docs/onchain/stdlib/TermList.mdx",sourceDirName:"onchain/stdlib",slug:"/onchain/stdlib/TermList",permalink:"/onchain/stdlib/TermList",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/onchain/stdlib/TermList.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"TermStr",permalink:"/onchain/stdlib/TermStr"},next:{title:"TermPair<PFstT,PSndT>",permalink:"/onchain/stdlib/TermPair"}},c={},o=[{value:"<code>head</code>",id:"head",level:2},{value:"<code>tail</code>",id:"tail",level:2},{value:"<code>length</code>",id:"length",level:2},{value:"<code>at</code>",id:"at",level:2},{value:"<code>find</code>",id:"find",level:2},{value:"<code>filter</code>",id:"filter",level:2},{value:"<code>prepend</code>",id:"prepend",level:2},{value:"<code>map</code>",id:"map",level:2},{value:"<code>every</code>",id:"every",level:2},{value:"<code>some</code>",id:"some",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",...(0,r.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"termlistpelemstype",children:(0,i.jsx)(n.code,{children:"TermList<PElemsType>"})}),"\n",(0,i.jsx)(n.p,{children:"type definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type TermList<PElemsT extends PDataRepresentable> = Term<PList<PElemsT>> & {\n\n    readonly head: UtilityTermOf<PElemsT>\n\n    readonly tail: TermList<PElemsT>\n\n    readonly length: TermInt\n\n    readonly atTerm:        TermFn<[PInt], PElemsT>\n    readonly at:            ( index: Term<PInt> ) => UtilityTermOf<PElemsT> \n    \n    readonly findTerm:      TermFn<[PLam<PElemsT,PBool>], PMaybeT<PElemsT>>\n    readonly find:          ( predicate: Term<PLam<PElemsT,PBool>> ) => Term<PMaybeT<PElemsT>>\n\n    readonly filterTerm:    TermFn<[PLam<PElemsT,PBool>], PList<PElemsT>>\n    readonly filter:        ( predicate: Term<PLam<PElemsT,PBool>> ) => TermList<PElemsT>\n\n    readonly preprendTerm:  TermFn<[PElemsT], PList<PElemsT>>\n    readonly preprend:      ( elem: Term<PElemsT> ) => TermList<PElemsT>\n    \n    readonly mapTerm: <ResultT extends ConstantableTermType>( resultT: ResultT ) =>\n        TermFn<[PLam<PElemsT, ToPType<ResultT>>], PList<ToPType<ResultT>>>\n    readonly map:     <PResultElemT extends PType>( f: Term<PLam<PElemsT,PResultElemT>> ) => \n        TermList<PResultElemT>\n\n    readonly everyTerm: TermFn<[PLam<PElemsT, PBool>], PBool>\n    readonly every:     ( predicate: Term<PLam<PElemsT, PBool>> ) => TermBool\n    \n    readonly someTerm:  TermFn<[PLam<PElemsT, PBool>], PBool>\n    readonly some:      ( predicate: Term<PLam<PElemsT, PBool>> ) => TermBool\n\n}\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{}),(0,i.jsxs)(n.p,{children:["most of the equivalent expressions and some of the terms that requre some other informations are ",(0,i.jsxs)(n.a,{href:"../Types#plu-ts-generics",children:[(0,i.jsx)(n.code,{children:"plu-ts"})," generics"]})]})]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["What is ",(0,i.jsx)(n.code,{children:"UtilityTermOf"}),"?"]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TermList"})," is a generic, and it works for every ",(0,i.jsx)(n.code,{children:"PType"})]}),(0,i.jsxs)(n.p,{children:["However, given a generic ",(0,i.jsx)(n.code,{children:"PType"})," we don't know what is its utility term or even if it has any"]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"UtilityTermOf"})," handles all that; if ",(0,i.jsx)(n.code,{children:"PElemsT"})," is something that can have an utility term it returns that utility term;\notherwise returns the plain term."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"example"})}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"UtilityTermOf<PByteString>"})," === ",(0,i.jsx)(n.code,{children:"TermBS"})]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"UtilityTermOf<PDelayed<PByteString>>"})," === ",(0,i.jsx)(n.code,{children:"Term<PDelayed<PByteString>>"})]})]}),"\n",(0,i.jsx)(n.h2,{id:"head",children:(0,i.jsx)(n.code,{children:"head"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"head"})}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"UtilityTermOf<PElemsT>"})]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"throws"})})," if the list is empty (",(0,i.jsx)(n.code,{children:"[]"}),")"]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"phead( elemsT ).$( term )\n"})})]}),"\n",(0,i.jsx)(n.p,{children:"returns the first element of the list"}),"\n",(0,i.jsx)(n.h2,{id:"tail",children:(0,i.jsx)(n.code,{children:"tail"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"tail"})}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"UtilityTermOf<PElemsT>"})]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"throws"})})," if the list is empty (",(0,i.jsx)(n.code,{children:"[]"}),")"]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"ptail( elemsT ).$( term )\n"})})]}),"\n",(0,i.jsx)(n.p,{children:"returns a new list with the same elements of the term except for the first one."}),"\n",(0,i.jsx)(n.h2,{id:"length",children:(0,i.jsx)(n.code,{children:"length"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"length"})}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"TermInt"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"plength( elemsT ).$( term )\n"})}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"O(n)"})})})]}),"\n",(0,i.jsx)(n.p,{children:"returns the number of elements present in the list."}),"\n",(0,i.jsx)(n.h2,{id:"at",children:(0,i.jsx)(n.code,{children:"at"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"at"})}),(0,i.jsxs)(n.p,{children:["parameter: ",(0,i.jsx)(n.code,{children:"index"})," type: ",(0,i.jsx)(n.code,{children:"Term<PInt>"})]}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"UtilityTermOf<PElemsT>"})]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"throws"})})," if ",(0,i.jsx)(n.code,{children:"index"})," >= ",(0,i.jsx)(n.code,{children:"length"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pindex( elemsT ).$( term ).$( index )\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["returns the element at position ",(0,i.jsx)(n.code,{children:"index"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"find",children:(0,i.jsx)(n.code,{children:"find"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"find"})}),(0,i.jsxs)(n.p,{children:["parameter: ",(0,i.jsx)(n.code,{children:"predicate"})," type: ",(0,i.jsx)(n.code,{children:"Term<PLam<PElemsT,PBool>>"})]}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"Term<PMaybeT<PElemsT>>"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pfind( elemsT ).$( predicate ).$( term )\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["returns ",(0,i.jsx)(n.code,{children:"PMaybe( elemsT ).Just({ val: elem })"})," where ",(0,i.jsx)(n.code,{children:"elem"})," is the first element of the list that satisfies the ",(0,i.jsx)(n.code,{children:"predicate"}),";\nreturns ",(0,i.jsx)(n.code,{children:"PMaybe( elemsT ).Nothing({})"})," if none of the elements satisfies the ",(0,i.jsx)(n.code,{children:"predicate"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"filter",children:(0,i.jsx)(n.code,{children:"filter"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"filter"})}),(0,i.jsxs)(n.p,{children:["parameter: ",(0,i.jsx)(n.code,{children:"predicate"})," type: ",(0,i.jsx)(n.code,{children:"Term<PLam<PElemsT,PBool>>"})]}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"TermList<PElemsT>"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pfilter( elemsT ).$( predicate ).$( term )\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["returns a new list containing only the elements that satisfy the ",(0,i.jsx)(n.code,{children:"predicate"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"prepend",children:(0,i.jsx)(n.code,{children:"prepend"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"prepend"})}),(0,i.jsxs)(n.p,{children:["parameter: ",(0,i.jsx)(n.code,{children:"elem"})," type: ",(0,i.jsx)(n.code,{children:"Term<PElemsT>"})]}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"TermList<PElemsT>"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pprepend( elemsT ).$( elem ).$( term )\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["returns a new list with the ",(0,i.jsx)(n.code,{children:"elem"})," element added at the start of the list."]}),"\n",(0,i.jsx)(n.h2,{id:"map",children:(0,i.jsx)(n.code,{children:"map"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"map"})}),(0,i.jsxs)(n.p,{children:["parameter: ",(0,i.jsx)(n.code,{children:"f"})," type: ",(0,i.jsx)(n.code,{children:"Term<PLam<PElemsT,PResultElemT>>"})]}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"TermList<PResultElemT>"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pmap( elemsT, resultT ).$( f ).$( term )\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["returns a new list containing the result of applying ",(0,i.jsx)(n.code,{children:"f"})," to the element in the same position."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"NOTE"})})," ",(0,i.jsx)(n.code,{children:"mapTerm"})," requires the return type of ",(0,i.jsx)(n.code,{children:"f"}),"; this is not true for ",(0,i.jsx)(n.code,{children:"map"})," because ",(0,i.jsx)(n.code,{children:"map"})," can understand the type directly from the parameter ",(0,i.jsx)(n.code,{children:"f"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"every",children:(0,i.jsx)(n.code,{children:"every"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"every"})}),(0,i.jsxs)(n.p,{children:["parameter: ",(0,i.jsx)(n.code,{children:"predicate"})," type: ",(0,i.jsx)(n.code,{children:"Term<PLam<PElemsT, PBool>>"})]}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"TermBool"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pevery( elemsT ).$( predicate ).$( list )\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["applies the ",(0,i.jsx)(n.code,{children:"predicate"})," to each term of the list and returns ",(0,i.jsx)(n.code,{children:"pBool( false )"})," if any of them is ",(0,i.jsx)(n.code,{children:"pBool( false )"}),"; ",(0,i.jsx)(n.code,{children:"pBool( true )"})," otherwise;"]}),"\n",(0,i.jsx)(n.h2,{id:"some",children:(0,i.jsx)(n.code,{children:"some"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{children:(0,i.jsx)(n.code,{children:"some"})}),(0,i.jsxs)(n.p,{children:["parameter: ",(0,i.jsx)(n.code,{children:"predicate"})," type: ",(0,i.jsx)(n.code,{children:"Term<PLam<PElemsT, PBool>>"})]}),(0,i.jsxs)(n.p,{children:["returns: ",(0,i.jsx)(n.code,{children:"TermBool"})]}),(0,i.jsx)(n.p,{children:"equivalent expression:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"psome( elemsT ).$( predicate ).$( list )\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["applies the ",(0,i.jsx)(n.code,{children:"predicate"})," to each term of the list and returns ",(0,i.jsx)(n.code,{children:"pBool( true )"})," if any of them is ",(0,i.jsx)(n.code,{children:"pBool( true )"}),"; ",(0,i.jsx)(n.code,{children:"pBool( false )"})," otherwise;"]})]})}function m(e={}){const{wrapper:n}={...(0,r.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},4552:(e,n,s)=>{s.d(n,{I:()=>t,M:()=>d});var i=s(11504);const r={},l=i.createContext(r);function d(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);