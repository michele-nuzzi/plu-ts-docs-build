"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[36872],{17048:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var s=t(17624),r=t(4552),i=t(61268),a=t(87768);const o={sidebar_position:1},c="Vesting",l={id:"examples/Vesting",title:"Vesting",description:"Now that we are a bit more familiar on how to interact properly with a smart contract,",source:"@site/docs/examples/Vesting.mdx",sourceDirName:"examples",slug:"/examples/Vesting",permalink:"/examples/Vesting",draft:!1,unlisted:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts-docs/docs/examples/Vesting.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Hello plu-ts",permalink:"/examples/Hello_World"},next:{title:"Minting policy",permalink:"/examples/Simple minting policy"}},d={},h=[{value:"Project set up",id:"project-set-up",level:2},{value:"Add dependencies",id:"add-dependencies",level:2},{value:"Template overview",id:"template-overview",level:3},{value:"Run the template",id:"run-the-template",level:3},{value:"The contract",id:"the-contract",level:2},{value:"<code>VestingDatum</code>",id:"vestingdatum",level:3},{value:"Contract signature",id:"contract-signature",level:3},{value:"Contract logic",id:"contract-logic",level:3},{value:"<code>signedByBeneficiary</code>",id:"signedbybeneficiary",level:2},{value:"<code>deadlineReached</code>",id:"deadlinereached",level:2},{value:"Compiling the contract",id:"compiling-the-contract",level:2},{value:"Setup Blockfrost API",id:"setup-blockfrost-api",level:2},{value:"Interacting with the contract",id:"interacting-with-the-contract",level:2},{value:"Save the script",id:"save-the-script",level:2},{value:"Get Addresses and their keys",id:"get-addresses-and-their-keys",level:2},{value:"Create a Vesting UTxO",id:"create-a-vesting-utxo",level:2},{value:"Read the script",id:"read-the-script",level:3},{value:"Get your address",id:"get-your-address",level:3},{value:"Query the address UTxOs",id:"query-the-address-utxos",level:3},{value:"Build the Transaciton",id:"build-the-transaciton",level:3},{value:"Sign and Submit",id:"sign-and-submit",level:3},{value:"Spend the locked UTxO",id:"spend-the-locked-utxo",level:2},{value:"Get all you need",id:"get-all-you-need",level:3},{value:"Build the Transaciton",id:"build-the-transaciton-1",level:3},{value:"Bonus: Return the tADA",id:"bonus-return-the-tada",level:2}];function p(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"vesting",children:"Vesting"}),"\n",(0,s.jsx)(n.p,{children:"Now that we are a bit more familiar on how to interact properly with a smart contract,\nlet's do a step forward and see if we can come up with a slightly more complex contract."}),"\n",(0,s.jsxs)(n.p,{children:["The final result can be found at ",(0,s.jsx)(n.a,{href:"https://github.com/HarmonicLabs/vesting-pluts",children:(0,s.jsx)(n.code,{children:"HarmonicLabs/vesting-pluts"})}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Check ",(0,s.jsx)(n.code,{children:"package.json"})," file at ",(0,s.jsx)(n.a,{href:"https://github.com/HarmonicLabs/vesting-pluts/blob/main/package.json",children:(0,s.jsx)(n.code,{children:"HarmonicLabs/vesting-pluts"})})," for versions of packages used lately."]})}),"\n",(0,s.jsx)(n.h2,{id:"project-set-up",children:"Project set up"}),"\n",(0,s.jsxs)(n.p,{children:["We will once again start from the ",(0,s.jsx)(n.a,{href:"https://github.com/HarmonicLabs/plu-ts-starter",children:(0,s.jsx)(n.code,{children:"plu-ts-starter"})})," template (with the plu-ts version ~0.8.2) :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/HarmonicLabs/plu-ts-starter.git\nmv plu-ts-starter vesting-pluts\ncd vesting-pluts\ngit remote remove origin\n"})}),"\n",(0,s.jsx)(n.p,{children:"this gives us a simple project structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"./vesting-pluts\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 Introduction\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 contract.ts\n\u2502   \u251c\u2500\u2500 index.ts\n\u2502   \u251c\u2500\u2500 MyDatum\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2514\u2500\u2500 MyRedeemer\n\u2502       \u2514\u2500\u2500 index.ts\n\u2514\u2500\u2500 tsconfig.json\n"})}),"\n",(0,s.jsx)(n.h2,{id:"add-dependencies",children:"Add dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["Just like the ",(0,s.jsx)(n.a,{href:"/examples/Hello_World",children:"Hello plu-ts"})," example; this project already comes with plu-ts as dependency;\nall we need to do to then is to run"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This time instead of working with Browser wallets, we will generate key pairs using ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey",children:"Web Crypto API"})," and thus generate address.\nWe will also be making use of ",(0,s.jsx)(n.a,{href:"https://blockfrost.io/",children:"Blockfrost API"})," to interact with the contract, address, transaction on/to-be-on chain (enabled with the package ",(0,s.jsx)(n.code,{children:"@harmoniclabs/blockfrost-pluts"}),")"]}),"\n",(0,s.jsx)(n.h3,{id:"template-overview",children:"Template overview"}),"\n",(0,s.jsx)(n.p,{children:"Before we dive in let's get familiar with the starter template."}),"\n",(0,s.jsxs)(n.p,{children:["If we now navigate to ",(0,s.jsx)(n.code,{children:"src/contract.ts"})," we see we have a very simple validator already!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:'import { Address, compile, Credential, pfn, Script, ScriptType, PScriptContext, unit, passert } from "@harmoniclabs/plu-ts";\n\nexport const contract = pfn([\n    PScriptContext.type\n],  unit )\n(( { redemeer, tx, purpose } ) => {\n    // always succeeds\n    return passert.$(true)\n});\n\n\n///////////////////////////////////////////////////////////////////\n// ------------------------------------------------------------- //\n// ------------------------- utilities ------------------------- //\n// ------------------------------------------------------------- //\n///////////////////////////////////////////////////////////////////\n\nexport const compiledContract = compile( contract );\n\nexport const script = new Script(\n    ScriptType.PlutusV3,\n    compiledContract\n);\n\nexport const scriptMainnetAddr = new Address(\n    "mainnet",\n    Credential.script(\n        script.hash\n    )\n);\n\nexport const scriptTestnetAddr = new Address(\n    "testnet",\n    Credential.script(\n        script.hash.clone()\n    )\n);\n\nexport default contract;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let's focus only on the contract for now."}),"\n",(0,s.jsxs)(n.p,{children:["As per the latest Plutus V3, this contract expects a mandatory ",(0,s.jsx)(n.code,{children:"PScriptContext"})," to validate a transaction."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"PScriptContext"})," is a predefined data structure that is passed by the ",(0,s.jsx)(n.code,{children:"cardano-node"})," itself that will run our smart contract."]}),"\n",(0,s.jsxs)(n.p,{children:["Finally, the contract is used in ",(0,s.jsx)(n.code,{children:"src/index.ts"})," which is our entry point."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/index.ts"',children:'import { script } from "./contract";\n\nconsole.log("validator compiled successfully! \ud83c\udf89\\n");\nconsole.log(\n    JSON.stringify(\n        script.toJson(),\n        undefined,\n        2\n    )\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The index just imports ",(0,s.jsx)(n.code,{children:"script"})," from ",(0,s.jsx)(n.code,{children:"src/contract.ts"})," and prints it out in the json form."]}),"\n",(0,s.jsxs)(n.p,{children:["If we go back to ",(0,s.jsx)(n.code,{children:"src/contract.ts"})," we see that the script is obtained using the following steps:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Compiling the validator with ",(0,s.jsx)(n.a,{href:"../onchain/API/utilities/compile",children:(0,s.jsx)(n.code,{children:"compile"})})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"\n// highlight-start\nexport const compiledContract = compile( contract );\n// highlight-end\n\nexport const script = new Script(\n    ScriptType.PlutusV3,\n    compiledContract\n);\n\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["Wrapping it in a ",(0,s.jsx)(n.code,{children:"Script"})," that can be used offchain"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"\nexport const compiledContract = compile( contract );\n\n// highlight-start\nexport const script = new Script(\n    ScriptType.PlutusV3,\n    compiledContract\n);\n// highlight-end\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"That is all we need for now."}),"\n",(0,s.jsx)(n.h3,{id:"run-the-template",children:"Run the template"}),"\n",(0,s.jsx)(n.p,{children:"If we did every step above correctly, we should be able to run"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run start\n"})}),"\n",(0,s.jsx)(n.p,{children:"and the output should look like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'validator compiled successfully! \ud83c\udf89\n\n{\n  "type": "PlutusScriptV3",\n  "description": "",\n  "cborHex": "515001010023259800800c5268b2ae689441"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Well congratulations \ud83e\udd73!"}),"\n",(0,s.jsx)(n.p,{children:"This is your first compiled smart contract \ud83c\udf89!"}),"\n",(0,s.jsx)(n.p,{children:"But we won't stop here for sure!"}),"\n",(0,s.jsx)(n.p,{children:"Let's personalize this smart contract."}),"\n",(0,s.jsx)(n.h2,{id:"the-contract",children:"The contract"}),"\n",(0,s.jsx)(n.p,{children:"The contract should succeed if the following two conditions are met:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["the transaction is signed by the ",(0,s.jsx)(n.code,{children:"PPubKeyHash"})," defined in the UTxO datum;"]}),"\n",(0,s.jsxs)(n.li,{children:["the transaction lower bound is ",(0,s.jsx)(n.code,{children:"Finite"})," and greater than the datum ",(0,s.jsx)(n.code,{children:"deadline"})," field;"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"vestingdatum",children:(0,s.jsx)(n.code,{children:"VestingDatum"})}),"\n",(0,s.jsx)(n.p,{children:"The first thing we notice is that we need a custom datum."}),"\n",(0,s.jsxs)(n.p,{children:["Let's create a folder ",(0,s.jsx)(n.code,{children:"VestingDatum"})," with ",(0,s.jsx)(n.code,{children:"index.ts"})," file to define the types ",(0,s.jsx)(n.code,{children:"beneficiary"})," and ",(0,s.jsx)(n.code,{children:"deadline"})," in the contract should hold."]}),"\n",(0,s.jsxs)(n.p,{children:["Now, modify ",(0,s.jsx)(n.code,{children:"src/contract.ts"})," as follows"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',children:'import { PPubKeyHash, int, pstruct } from "@harmoniclabs/plu-ts";\n\n// modify the Datum as you prefer\nconst VestingDatum = pstruct({\n    VestingDatum: {\n        beneficiary: PPubKeyHash.type,\n        deadline: int // posix time\n    }\n});\n\nexport default VestingDatum;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"contract-signature",children:"Contract signature"}),"\n",(0,s.jsxs)(n.p,{children:["There is no change in the contract signature, as all details about the transaction and the purpose of the script within the transaction are embedded within ",(0,s.jsx)(n.code,{children:"PScriptContext"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"/* imports */\n\nexport const contract = pfn([\n    // highlight-start\n    PScriptContext.type\n    // highlight-end\n],  unit)\n// highlight-start\n(( {redeemer, tx, purpose} ) => {\n// highlight-end\n    /* contract logic */\n\n});\n\n/* other code */\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"contract-logic",children:"Contract logic"}),"\n",(0,s.jsxs)(n.p,{children:["We know for sure that we need 2 conditions. So we will check them separately using two terms- ",(0,s.jsx)(n.code,{children:"signedByBeneficiary"})," and ",(0,s.jsx)(n.code,{children:"deadlineReached"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Now that we have our datum structure, we can use it in the contract definition."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:'/* imports */\n\nexport const contract = pfn([\n    PScriptContext.type\n],  unit)\n(( {redeemer, tx, purpose} ) => {\n    // highlight-start\n\n    const maybeDatum = plet(\n        pmatch(purpose)\n        .onSpending(({ datum }) => datum)\n        ._(_ => perror(PMaybe(data).type))\n    );\n\n    const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )\n\n    const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )\n\n    // inlined\n    const deadlineReached = plet(\n        pmatch( tx.interval.from.bound )\n        .onPFinite(({ n: lowerInterval }) =>\n            datum.deadline.ltEq( lowerInterval ) \n        )\n        ._( _ => pBool( false ) )\n    )\n\n    return passert.$(\n        (ptraceIfFalse.$(pdelay(pStr("Error in signedByBenificiary"))).$(signedByBeneficiary))\n        .and( ptraceIfFalse.$(pdelay(pStr("deadline not reached or not specified"))).$( deadlineReached ) )\n    );\n\n    // highlight-end\n});\n\n/* other code */\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We just initialize them to ",(0,s.jsx)(n.code,{children:"pBool( false )"})," so that if we forget them the contract fails."]}),"\n",(0,s.jsx)(n.p,{children:"But we can already see the structure of the contract this way: we have two conditions, and we want both to be true."}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["What's ",(0,s.jsx)(n.code,{children:"// inlined"})," for?"]}),(0,s.jsxs)(n.p,{children:["As defined above the terms are inlined ",(0,s.jsx)(n.strong,{children:"every time that are used"}),"."]}),(0,s.jsxs)(n.p,{children:["This is because we are not using ",(0,s.jsx)(n.a,{href:"../onchain/Optimizations/plet",children:(0,s.jsx)(n.code,{children:"plet"})})," to create an actual ",(0,s.jsx)(n.code,{children:"plu-ts"})," variable. Instead we are just holding a reference to that piece of code."]}),(0,s.jsxs)(n.p,{children:["This is not necessarily bad because it helps making the contract more readable (and ",(0,s.jsx)(n.code,{children:"plet"})," would have inlined the term anyway in this particular case for efficiency)."]}),(0,s.jsxs)(n.p,{children:["But, it is definitely useful to keep in mind that what we have is ",(0,s.jsx)(n.strong,{children:"always"})," inlined with a small comment."]})]}),"\n",(0,s.jsx)(n.h2,{id:"signedbybeneficiary",children:(0,s.jsx)(n.code,{children:"signedByBeneficiary"})}),"\n",(0,s.jsx)(n.p,{children:"The first condition for the contract to succeed is:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["the transaction is signed by the ",(0,s.jsx)(n.code,{children:"PPubKeyHash"})," defined in the UTxO datum;"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To check that we can use the ",(0,s.jsxs)(n.a,{href:"../onchain/API/types/V3/ScriptContext/PTxInfo#signatories",children:[(0,s.jsx)(n.code,{children:"signatories"})," field"]})," defined in the ",(0,s.jsx)(n.a,{href:"../onchain/API/types/V3/ScriptContext/PTxInfo",children:(0,s.jsx)(n.code,{children:"PTxInfo"})})," struct."]}),"\n",(0,s.jsx)(n.p,{children:"We can access the field from the transaction using the dot notation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tx.signatories\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"signatories"})," field is a list of ",(0,s.jsx)(n.code,{children:"PPubKeyHash"}),"; so we have access to all the ",(0,s.jsx)(n.a,{href:"../onchain/stdlib/TermList",children:(0,s.jsx)(n.code,{children:"TermList"})})," methods."]}),"\n",(0,s.jsxs)(n.p,{children:["so we can use the ",(0,s.jsxs)(n.a,{href:"../onchain/stdlib/TermList#some",children:[(0,s.jsx)(n.code,{children:"some"})," method"]})," to check that ",(0,s.jsx)(n.strong,{children:"at least one"})," element of the list satisfies a given predicate."]}),"\n",(0,s.jsx)(n.p,{children:"In our case:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tx.signatories.some( signer => signer.eq( datum.beneficiary ) );\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or the equivalent (but slightly more efficient)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tx.signatories.some( datum.beneficiary.eq );\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, we would define the ",(0,s.jsx)(n.code,{children:"beneficiary"})," and ",(0,s.jsx)(n.code,{children:"deadline"})," in ",(0,s.jsx)(n.code,{children:"datum"})," of the ",(0,s.jsx)(n.em,{children:"spending transaction"}),"(in ",(0,s.jsx)(n.code,{children:"src/app/createVesting.ts"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["To use them, extract the ",(0,s.jsx)(n.code,{children:"maybeDatum"})," from ",(0,s.jsx)(n.code,{children:"purpose"}),", and then properly type convert to ultimately get ",(0,s.jsx)(n.code,{children:"datum"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"const maybeDatum = plet(\n    pmatch(purpose)\n    .onSpending(({ datum }) => datum)\n    ._(_ => perror(PMaybe(data).type))\n);\n\nconst datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )\n"})}),"\n",(0,s.jsx)(n.p,{children:"And that's it!"}),"\n",(0,s.jsxs)(n.p,{children:["Our ",(0,s.jsx)(n.code,{children:"signedByBeneficiary"})," condition is ready"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"const maybeDatum = plet(\n    pmatch(purpose)\n    .onSpending(({ datum }) => datum)\n    ._(_ => perror(PMaybe(data).type))\n);\n\nconst datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )\n\nconst signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )\n"})}),"\n",(0,s.jsx)(n.h2,{id:"deadlinereached",children:(0,s.jsx)(n.code,{children:"deadlineReached"})}),"\n",(0,s.jsx)(n.p,{children:"Now we can pass to the second condition:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["the transaction lower bound is ",(0,s.jsx)(n.code,{children:"Finite"})," and greater than the datum ",(0,s.jsx)(n.code,{children:"deadline"})," field"]}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["but what do we mean by ",(0,s.jsx)(n.em,{children:'"transaction lower bound"'}),"?"]}),(0,s.jsx)(n.p,{children:"That is due to how time is handled on-chain."}),(0,s.jsx)(n.p,{children:"Handling time on chain is definitely not something simple due to the fact that the underlying system is distributed."}),(0,s.jsx)(n.p,{children:"That means that we can't really be 100% sure of the exact moment the script is executed."}),(0,s.jsx)(n.p,{children:"To work around this problem, time is represented on chain with a range in which the transaction is considered valid."}),(0,s.jsx)(n.p,{children:"If ever the transaction where sent outside of the range, it would be rejected by the node before even executing the script!"}),(0,s.jsx)(n.p,{children:"So we can at least be sure that the script is executed in the given time range."})]}),"\n",(0,s.jsxs)(n.p,{children:["We can access the transaction validity time range trough the ",(0,s.jsxs)(n.a,{href:"../onchain/API/types/V3/ScriptContext/PTxInfo#interval",children:[(0,s.jsx)(n.code,{children:"interval"})," property"]})," of the ",(0,s.jsx)(n.a,{href:"../onchain/API/types/V3/ScriptContext/PTxInfo",children:(0,s.jsx)(n.code,{children:"PTxInfo"})})," struct."]}),"\n",(0,s.jsx)(n.p,{children:"This is done once again using the dot notation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tx.interval\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"interval"})," type is somewhat complex due to the nested structure; we have"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["two initial properties (",(0,s.jsx)(n.code,{children:"from"})," and ",(0,s.jsx)(n.code,{children:"to"}),") representing the lower and upper bound."]}),"\n",(0,s.jsxs)(n.li,{children:["both the properties then have a ",(0,s.jsx)(n.code,{children:"bound"})," property and an ",(0,s.jsx)(n.code,{children:"inclusive"})," property which is a boolean\n(of the two we are only interested in the ",(0,s.jsx)(n.code,{children:"bound"})," one)"]}),"\n",(0,s.jsxs)(n.li,{children:["finally the ",(0,s.jsx)(n.code,{children:"bound"})," has 3 constructors as below"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const PExtended = pstruct({\n    PNegInf: {},\n    PFinite: { n: int },\n    PPosInf: {}\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"PFinite"})," is the one we are interested in."]}),"\n",(0,s.jsxs)(n.p,{children:["So reaching the ",(0,s.jsx)(n.code,{children:"bound"})," field is the easy part and can be done as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tx.interval.from.bound\n"})}),"\n",(0,s.jsxs)(n.p,{children:["But then we have to use ",(0,s.jsx)(n.a,{href:"../onchain/Control%20Flow/pmatch",children:(0,s.jsx)(n.code,{children:"pmatch"})})," to understand what constructor was used."]}),"\n",(0,s.jsxs)(n.p,{children:["In particular, we are only interested in the ",(0,s.jsx)(n.code,{children:"PFinite"})," one. So we'll use the underscore (",(0,s.jsx)(n.code,{children:"_"}),") wildcard to match the other two."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"pmatch( tx.interval.from.bound )\n.onPFinite(({ n: lowerInterval }) => \n    /* deadline condition */\n)\n._( _ => pBool( false ) )\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now that we have access to the transaction lower bound, we can finally check for the deadline to have been passed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"datum.deadline.ltEq( lowerInterval ) \n"})}),"\n",(0,s.jsxs)(n.p,{children:["The final ",(0,s.jsx)(n.code,{children:"deadlineReached"})," condition becomes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"// inlined\nconst deadlineReached = plet(\n    pmatch( tx.interval.from.bound )\n    .onPFinite(({ n: lowerInterval }) =>\n        datum.deadline.ltEq( lowerInterval ) \n    )\n    ._( _ => pBool( false ) )\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For debugging closely in case the contract fails due to ",(0,s.jsx)(n.code,{children:"deadlineReached"})," condition, and to throw a specific error in that case, we can add ",(0,s.jsx)(n.code,{children:"pTrace"})," to the return statement and modify it as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:'return passert.$(\n        (ptraceIfFalse.$(pdelay(pStr("Error in signedByBenificiary"))).$(signedByBeneficiary))\n        .and( ptraceIfFalse.$(pdelay(pStr("deadline not reached or not specified"))).$( deadlineReached ) )\n);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"compiling-the-contract",children:"Compiling the contract"}),"\n",(0,s.jsx)(n.p,{children:"Our smart contract should now look something like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:'export const contract = pfn([\n    PScriptContext.type\n],  unit)\n(( {redeemer, tx, purpose} ) => {\n\n  const maybeDatum = plet(\n    pmatch(purpose)\n    .onSpending(({ datum }) => datum)\n    ._(_ => perror(PMaybe(data).type))\n  );\n\n     const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )\n\n     const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )\n\n    // inlined\n    const deadlineReached = plet(\n        pmatch( tx.interval.from.bound )\n        .onPFinite(({ n: lowerInterval }) =>\n            datum.deadline.ltEq( lowerInterval ) \n        )\n        ._( _ => pBool( false ) )\n    )\n\n    return passert.$(\n        (ptraceIfFalse.$(pdelay(pStr("Error in signedByBenificiary"))).$(signedByBeneficiary))\n        .and( ptraceIfFalse.$(pdelay(pStr("deadline not reached or not specified"))).$( deadlineReached ) )\n      );\n\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As we saw in the ",(0,s.jsx)(n.a,{href:"/examples/Hello_World",children:"Hello plu-ts example project"}),", we can compile the contract\nby passing the term to the ",(0,s.jsx)(n.a,{href:"../onchain/API/utilities/compile",children:(0,s.jsx)(n.code,{children:"compile"})})," function."]}),"\n",(0,s.jsxs)(n.p,{children:["We finally pass the compiled Contract to the ",(0,s.jsx)(n.code,{children:"Script"})," constructor so that we can use it properly."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/contract.ts"',children:"/* contract definition above */\n\nexport const compiledContract = compile( contract );\n\nexport const script = new Script(\n    ScriptType.PlutusV3,\n    compiledContract\n);\n\n/* some other code */\n"})}),"\n",(0,s.jsx)(n.p,{children:"So now running the project using"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run start\n"})}),"\n",(0,s.jsx)(n.p,{children:"we should see something like this"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'validator compiled successfully! \ud83c\udf89\n\n{\n  "type": "PlutusScriptV3",\n  "description": "",\n  "cborHex": "59022d59022a0101003232323232323223232323259800800c5268b2ae686644b3001002800c5282ae6866016292011c4572726f7220696e207369676e6564427942656e69666963696172790033233009214a04446644b30010028a51800aae68600800426006002466e3cdd71aba10020013323323009235740600400200297ac475c6eb0c8d5d09aba2357446ae88d5d11aba2357446ae88d5d10008010998058a48125646561646c696e65206e6f742072656163686564206f72206e6f7420737065636966696564003298009aba1300735742600e646ae84d5d11aba2357446ae88d5d11aba235744002007001919b89375a600e0066eb4d5d0800c005222232332598009800a400110038acc004c00520028802456600260029002440162cab9a2ae68ab9a1b8735573a0026aae78004dd500209281802991aba135573c6ea8004ca6002646ae84d5d11aba2001003800c00600300191803000c005222222232332598009800a400110038acc004c00520028802456600260029002440162b300130014801a200d1598009800a401110078acc004c005200a8804459573455cd1573455cd1573455cd0dc39aab9d00135573c0026ea801c4c60086ae84004c00c0048d5d09aba2001235573c6ea800488cc00c84008888cc014008c00c004c0088888ca600260080033003001801200c3300400300222259800800c00e2660046ae84004d5d1000aaae7c46460044660040040024600446600400400244b30010018a51899ab9c50024a0ab9a1"\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"setup-blockfrost-api",children:"Setup Blockfrost API"}),"\n",(0,s.jsx)(n.p,{children:"First and foremost, we need to setup Blockfrost API to use in our app."}),"\n",(0,s.jsxs)(n.p,{children:["It is enabled by the package ",(0,s.jsx)(n.code,{children:"@harmoniclabs/blockfrost-pluts"}),". In your terminal, do"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @harmoniclabs/blockfrost-pluts\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Go to ",(0,s.jsx)(n.a,{href:"https://blockfrost.io/",children:"https://blockfrost.io/"})," and create a new project for this example (a free plan is more than enough for now). Make sure to pick ",(0,s.jsx)(n.code,{children:"Preprod"})," as your preferred network."]}),"\n",(0,s.jsx)(n.p,{children:"Once done, navigate to the Dashboard and copy over PROJECT_ID to setup."}),"\n",(0,s.jsxs)(n.p,{children:["Now, create file ",(0,s.jsx)(n.code,{children:"blockfrost.ts"})," within ",(0,s.jsx)(n.code,{children:"src/app"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/blockfrost.ts"',children:'import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\n\nfunction blockfrost () {\n    const provider = new BlockfrostPluts({\n        projectId: "Paste your PROJECT_ID here"\n    });\n    return provider;\n}\n\nexport default blockfrost;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Make sure to not check-in your PROJECT_ID into any versioning systems. Alternatively, you can always use environment variables here."}),"\n",(0,s.jsxs)(n.p,{children:["To enable blockfrost within other files, we will instantiate ",(0,s.jsx)(n.code,{children:"blockfrost()"})," with the PROJECT_ID."]}),"\n",(0,s.jsxs)(n.p,{children:["To perform transactions through Blockfrost, we need to instantiate our ",(0,s.jsx)(n.code,{children:"TxBuilder"})," with Blockfrost."]}),"\n",(0,s.jsxs)(n.p,{children:["Create file ",(0,s.jsx)(n.code,{children:"getTxBuilder.ts"})," within ",(0,s.jsx)(n.code,{children:"src/app"}),", exporting method ",(0,s.jsx)(n.code,{children:"getTxBuilder()"})," which will thus be used to instantiate an instance of ",(0,s.jsx)(n.code,{children:"TxBuilder"})," and further used."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/getTxBuilder.ts"',children:'import { TxBuilder } from "@harmoniclabs/plu-ts";\nimport { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\n\n/**\n * we don\'t want to do too many API call if we already have our `txBuilder`\n * \n * so after the first call we\'ll store a copy here.\n**/\nlet _cachedTxBuilder: TxBuilder | undefined = undefined\n\nexport default async function getTxBuilder(Blockfrost: BlockfrostPluts): Promise<TxBuilder>\n{\n    if(!( _cachedTxBuilder instanceof TxBuilder ))\n    {\n        const parameters = await Blockfrost.getProtocolParameters();\n        _cachedTxBuilder = new TxBuilder(parameters);\n    }\n\n    return _cachedTxBuilder;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"interacting-with-the-contract",children:"Interacting with the contract"}),"\n",(0,s.jsxs)(n.p,{children:["We will use the native ",(0,s.jsx)(n.code,{children:"npm"})," script functionality to define some scripts to interact arbitrarily with our new contract."]}),"\n",(0,s.jsxs)(n.p,{children:["We can define a new script by adding an entry in the ",(0,s.jsx)(n.code,{children:"scripts"})," field of the ",(0,s.jsx)(n.code,{children:"package.json"})," file that you find in the root of the project."]}),"\n",(0,s.jsx)(n.p,{children:"Right now you should see something like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"scripts": {\n    "build": "tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json",\n    "start": "npm run build && node dist/index.js"\n},\n'})}),"\n",(0,s.jsx)(n.p,{children:"We can add our own scripts by specifying the script name as key and the command to execute as value."}),"\n",(0,s.jsxs)(n.p,{children:["As an example, say we want a better name for the ",(0,s.jsx)(n.code,{children:'"start"'})," script, we could do something like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"scripts": {\n    "build": "tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json",\n    "start": "npm run build && node dist/index.js",\n    // highlight-next-line\n    "vesting:compile": "npm run start"\n},\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now running"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run vesting:compile\n"})}),"\n",(0,s.jsxs)(n.p,{children:["is equivalent to ",(0,s.jsx)(n.code,{children:"npm run start"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To keep the project clean we'll create a new directory under ",(0,s.jsx)(n.code,{children:"src"})," called ",(0,s.jsx)(n.code,{children:"app"})," where all our scripts will be."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"./vesting-pluts\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 app\n"})}),"\n",(0,s.jsx)(n.h2,{id:"save-the-script",children:"Save the script"}),"\n",(0,s.jsx)(n.p,{children:"Now we can start working with the off-chain part of plu-ts."}),"\n",(0,s.jsx)(n.p,{children:"Let's start by saving the compiled script to a file when we compile it."}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"src/index.ts"})," file add the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/index.ts"',children:'// highlight-start\nimport { existsSync } from "fs";\nimport { mkdir, writeFile } from "fs/promises";\n// highlight-end\n\n/* old code */\n\n// highlight-start\nasync function main() \n{\n    if( !existsSync("./testnet") )\n    {\n        await mkdir("./testnet");\n    }\n    await writeFile("./testnet/vesting.plutus.json", JSON.stringify(script.toJson(), undefined, 4))\n}\nmain();\n// highlight-end\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now running"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run vesting:compile\n"})}),"\n",(0,s.jsxs)(n.p,{children:["should still print a success result; but it will also create a new ",(0,s.jsx)(n.code,{children:"testnet"})," directory with the file ",(0,s.jsx)(n.code,{children:"vesting.plutus.json"})," in it."]}),"\n",(0,s.jsx)(n.h2,{id:"get-addresses-and-their-keys",children:"Get Addresses and their keys"}),"\n",(0,s.jsx)(n.p,{children:"Depending on if you are working in private or public testnet,\nthere are 2 way to get your keys and start creating transactions."}),"\n",(0,s.jsxs)(i.c,{children:[(0,s.jsxs)(a.c,{value:"Public testnet",label:"Public testnet",default:!0,children:[(0,s.jsxs)(n.p,{children:["You can generate your own key pair using ",(0,s.jsx)(n.code,{children:"generateKey()"})," method from Crypto Web API. Read more about this ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey",children:"here"}),"."]}),(0,s.jsxs)(n.p,{children:["Using this, to generate 2 pairs of keys, create a file ",(0,s.jsx)(n.code,{children:"genKeys.ts"})," in the ",(0,s.jsx)(n.code,{children:"app"})," folder that looks like this"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/genKeys.ts"',children:'import { existsSync } from "fs";\nimport { Address, Credential, PublicKey, PrivateKey, PubKeyHash } from "@harmoniclabs/plu-ts";\nimport { config } from "dotenv";\nimport { mkdir, writeFile } from "fs/promises";\n\nimport pkg from \'blakejs\';\nconst { blake2b } = pkg;\n\nconfig();\n\nasync function genKeys()\n{\n    const nKeys = 2;\n\n    const promises: Promise<any>[] = [];\n\n    if( !existsSync("./testnet") )\n    {\n        await mkdir("./testnet");\n    }\n    \n    for( let i = 1; i <= nKeys; i++ )\n    {\n        // generate public-private keypair\n        let keyPair = await globalThis.crypto.subtle.generateKey(\n            {\n                name: "Ed25519",\n                namedCurve: "Ed25519"\n              },\n              true,\n              ["sign", "verify"]\n          );\n        \n\n        // convert keyPair.(publicKey|privateKey)<CryptoKeyPair> ultimately to PublicKey which can be converted to cborString to store it for future reference\n\n        // Export public key in a way compatible to Cardano CLI\n        const publicKeyArrayBuffer = await globalThis.crypto.subtle.exportKey(\'raw\', keyPair.publicKey); \n        const publicKeyUint8Array = new Uint8Array(publicKeyArrayBuffer);\n        const publicKey = new PublicKey(publicKeyUint8Array);\n        const publicKeyHash = new PubKeyHash(blake2b(publicKeyUint8Array, undefined, 28)); // to build Credential\n        const pubKeyJsonObj = {\n            type: "PaymentVerificationKeyShelley_ed25519",\n            description: "Payment Verification Key",\n            cborHex: publicKey.toCbor().toString()\n        }; // JSON structure similar to the one generated when by Cardano CLI\n        const pubKeyJsonStr = JSON.stringify(pubKeyJsonObj, null, 4);\n        await writeFile(`./testnet/payment${i}.vkey`, pubKeyJsonStr);\n\n        // Export of the private key in a way that\'s compatible with the Cardano CLI\n        const privateKeyArrayBuffer = await globalThis.crypto.subtle.exportKey(\'pkcs8\', keyPair.privateKey); // privateKey cannot be exported \'raw\' hence \'pkcs8\'\n        const privateKeyUint8Array = new Uint8Array(privateKeyArrayBuffer.slice(-32));\n        const privateKey = new PrivateKey(privateKeyUint8Array);\n        const pvtKeyJsonObj = {\n            type: "PaymentSigningKeyShelley_ed25519",\n            description: "Payment Signing Key",\n            cborHex: privateKey.toCbor().toString()\n        }; // JSON structure similar to the one generated when by Cardano CLI\n        const pvtKeyJsonStr = JSON.stringify(pvtKeyJsonObj, null, 4);\n        await writeFile(`./testnet/payment${i}.skey`, pvtKeyJsonStr);\n\n        // Check that the derivations went fine\n        const pubKeyfromPriv = privateKey.derivePublicKey();\n        if (pubKeyfromPriv.toString() !== publicKey.toString()) {\n            throw new Error("\\tPublic key derivation from private key failed");\n        }\n        else {\n            console.log("\\tPublic key derivation from private key succeeded");\n        }\n\n        // Create the address\n        const credential = Credential.keyHash(publicKeyHash);\n        const address = new Address("testnet", credential);\n        await writeFile(`./testnet/address${i}.addr`, address.toString());\n    }   \n\n    // wait for all files to be copied\n    await Promise.all( promises );\n}\ngenKeys();\n'})}),(0,s.jsxs)(n.p,{children:["Add a new  ",(0,s.jsx)(n.code,{children:"npm"})," script  ",(0,s.jsx)(n.code,{children:"vesting:genKeys"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:genKeys": "npm run build:light && node dist/app/genKeys.js"\n}\n'})}),(0,s.jsx)(n.p,{children:"so that running"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run vesting:genKeys\n"})}),(0,s.jsxs)(n.p,{children:["should give us 2 pairs of keys and 2 addresses under the ",(0,s.jsx)(n.code,{children:"testnet"})," folder."]}),(0,s.jsxs)(n.admonition,{title:"get some funds",type:"info",children:[(0,s.jsxs)(n.p,{children:["Remember to fund the addresses. In this example, make sure to fund ",(0,s.jsx)(n.strong,{children:"address1"})," and ",(0,s.jsx)(n.strong,{children:"address2"}),"; just so that there has been some transactions involving these addresses, and they appear on blockchain and inturn be visible for Blockfrost. Read more about such possible Blockfrost error ",(0,s.jsx)(n.a,{href:"https://blockfrost.dev/support/cardano#querying-address-returns-404-not-found-but-my-address-is-valid",children:"here"}),"."]}),(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.a,{href:"https://docs.cardano.org/cardano-testnet/tools/faucet",children:"Cardano Testnet Faucet"})," to get some testnet funds. Just be sure to select ",(0,s.jsx)(n.code,{children:"Preprod"})," testnet."]})]})]}),(0,s.jsxs)(a.c,{value:"Private testnet",label:"Private testnet",children:[(0,s.jsx)(n.p,{children:"If you are working in the private testnet then you probably want to use some keys you already have."}),(0,s.jsxs)(n.p,{children:["Then maybe you can copy those keys in the ",(0,s.jsx)(n.code,{children:"testnet"})," folder we have here."]}),(0,s.jsxs)(n.p,{children:["To do so we can set up a new ",(0,s.jsx)(n.code,{children:"setup.ts"})," script under the ",(0,s.jsx)(n.code,{children:"app"})," folder:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/setup.ts"',children:'import { existsSync } from "fs";\nimport { config } from "dotenv";\nimport { copyFile, mkdir } from "fs/promises";\n\nconfig();\n\nasync function setup()\n{\n    const privateTestnet = process.env.PRIVATE_TESTNET_PATH ?? ".";\n\n    const nKeys = 3;\n\n    const promises: Promise<any>[] = [];\n    if( !existsSync("./testnet") )\n    {\n        await mkdir("./testnet");\n    }\n    \n    for( let i = 1; i <= nKeys; i++ )\n    {\n        promises.push(\n            copyFile(`${privateTestnet}/addresses/payment${i}.addr`, `./testnet/address${i}.addr`),\n            copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.vkey`, `./testnet/payment${i}.vkey`),\n            copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.skey`, `./testnet/payment${i}.skey`)\n        );\n    }\n\n    // wait for all files to be copied\n    await Promise.all( promises );\n}\nsetup();\n'})}),(0,s.jsxs)(n.p,{children:["And then include a new ",(0,s.jsx)(n.code,{children:"npm script"})," in ",(0,s.jsx)(n.code,{children:"package.json"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:setup": "npm run build:light && node dist/app/setup.js"\n}\n'})}),(0,s.jsx)(n.p,{children:"so that you can now run"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run vesting:setup\n"})}),(0,s.jsxs)(n.p,{children:["to have your keys and addresses copied in the ",(0,s.jsx)(n.code,{children:"testnet"})," folder."]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"create-a-vesting-utxo",children:"Create a Vesting UTxO"}),"\n",(0,s.jsx)(n.p,{children:"Now we can finally start playing around with the vesting contract."}),"\n",(0,s.jsx)(n.h3,{id:"read-the-script",children:"Read the script"}),"\n",(0,s.jsx)(n.p,{children:"Since we already have our file compiled and saved, it is probably a good idea to read the compiled result instead of re-compiling the contract each time we run the script."}),"\n",(0,s.jsxs)(n.p,{children:["To do so, we can always read the saved ",(0,s.jsx)(n.code,{children:"Script"}),". First we need to read the ",(0,s.jsx)(n.code,{children:"vesting.plutus.json"})," file as string."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Then, to finally retrieve the ",(0,s.jsx)(n.code,{children:"Script"})," from the ",(0,s.jsx)(n.code,{children:"cborHex"})," in the JSON file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Make sure to specify ",(0,s.jsx)(n.code,{children:"ScriptType.PlutusV3"})," as second argument to ",(0,s.jsx)(n.a,{href:"../offchain/cardano-ledger-ts/classes/Script#fromcbor",children:(0,s.jsx)(n.code,{children:"Script.fromCbor"})})," even though it is optional, because the ",(0,s.jsx)(n.code,{children:"defType"})," arg is by default ",(0,s.jsx)(n.code,{children:"Script.PlutusV2"})," which being legacy."]})}),"\n",(0,s.jsxs)(n.p,{children:["From here we can generate the script address using the ",(0,s.jsx)(n.code,{children:"Address"})," class (from the offchain of ",(0,s.jsx)(n.code,{children:"plu-ts"}),") and the ",(0,s.jsx)(n.code,{children:"Script"})," as ",(0,s.jsx)(n.code,{children:"Credential"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const scriptAddr = new Address(\n    "testnet",\n    new Credential(CredentialType.Script, script.hash)\n);\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Generate Address",type:"info",children:(0,s.jsxs)(n.p,{children:["Instead of ",(0,s.jsx)(n.code,{children:'new Address("testnet", ...)'}),", we can also do ",(0,s.jsx)(n.code,{children:"Address.testnet(...)"}),". Read more ",(0,s.jsx)(n.a,{href:"../offchain/cardano-ledger-ts/classes/Address#testnet",children:"here"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"get-your-address",children:"Get your address"}),"\n",(0,s.jsx)(n.p,{children:"Now, to build and send our transaction we are just missing the sender key, address and the beneficiary public key."}),"\n",(0,s.jsxs)(n.p,{children:["Once again we retrieve them from our saved files using node.js ",(0,s.jsx)(n.code,{children:"readFile"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const privateKeyFile = await readFile("./testnet/payment1.skey", { encoding: "utf-8" });\nconst privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );\n\nconst addr = await readFile("./testnet/address1.addr", { encoding: "utf-8" });\nconst address = Address.fromString(addr);\n    \nconst publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });\nconst pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"query-the-address-utxos",children:"Query the address UTxOs"}),"\n",(0,s.jsx)(n.p,{children:"Before we really start building our transaction we need some UTxOs to use as input. We can query the UTxOs available in our address through Blockfrost.\nMake sure to populate both the addresses with some funds."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const utxos = await Blockfrost.addressUtxos( address );\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Instead of blindly assigning the first UTxO of the utxos[] as input, let us assure that we use the UTxO that has atleast 15 ada in it just to avoid possible failures."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000)!;\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"build-the-transaciton",children:"Build the Transaciton"}),"\n",(0,s.jsx)(n.p,{children:"Our transaction will be constructed as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"our UTxO as input"}),"\n",(0,s.jsxs)(n.li,{children:["an output to the contract with an attached ",(0,s.jsx)(n.code,{children:"VestingDatum"})]}),"\n",(0,s.jsx)(n.li,{children:"the change going back to the address"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"which translates to the following code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"let tx = await txBuilder.buildSync({\n    inputs: [{ utxo: utxo }],\n    collaterals: [ utxo ],\n    outputs: [\n        {\n            address: scriptAddr,\n            value: Value.lovelaces( 10_000_000 ),\n            // highlight-start\n            datum: VestingDatum.VestingDatum({\n                beneficiary: pBSToData.$( pByteString( pkh.toBuffer() ) ),\n                deadline: pIntToData.$( nowPosix + 10_000 )\n            })\n            // highlight-end\n        }\n    ],\n    changeAddress: address\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Have you noticed?",type:"info",children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"datum"})," attached to the output is generated using on-chain code!"]}),(0,s.jsxs)(n.p,{children:["This is done, thanks to plu-ts, being able to evaluate on-chain code and use the result as ",(0,s.jsx)(n.code,{children:"Data"}),"."]}),(0,s.jsxs)(n.p,{children:["This way we can use the on-chain types to describe the plutus data off-chain, without the need to use low level ",(0,s.jsx)(n.code,{children:"Data"})," elements!"]})]}),"\n",(0,s.jsx)(n.h3,{id:"sign-and-submit",children:"Sign and Submit"}),"\n",(0,s.jsx)(n.p,{children:"Now that we have our transaction, all we need is just to Sign and Submit it."}),"\n",(0,s.jsx)(n.p,{children:"And guess what?"}),"\n",(0,s.jsxs)(n.p,{children:["This is now extremly easy with ",(0,s.jsx)(n.code,{children:"plu-ts"})," and ",(0,s.jsx)(n.code,{children:"Blockfrost"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await tx.signWith( new PrivateKey(privateKey) );\n\nconst submittedTx = await Blockfrost.submitTx( tx );\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All we need to do now is to put it all together in a file ",(0,s.jsx)(n.code,{children:"createVesting.ts"})," under the ",(0,s.jsx)(n.code,{children:"app"})," folder."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/createVesting.ts"',children:'import { Address, Credential, Hash28, PrivateKey, Value, pBSToData, pByteString, pIntToData, CredentialType, PublicKey, Script, ScriptType } from "@harmoniclabs/plu-ts";\nimport VestingDatum from "../VestingDatum";\nimport getTxBuilder from "./getTxBuilder";\nimport { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\nimport blockfrost from "./blockfrost";\nimport { readFile } from "fs/promises";\n\nasync function createVesting(Blockfrost: BlockfrostPluts)\n{   \n    const txBuilder = await getTxBuilder(Blockfrost);\n     \n    const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });\n    const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)\n    const scriptAddr = new Address(\n        "testnet",\n        new Credential(CredentialType.Script, script.hash)\n    );\n    \n    const privateKeyFile = await readFile("./testnet/payment1.skey", { encoding: "utf-8" });\n    const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );\n    \n    const addr = await readFile("./testnet/address1.addr", { encoding: "utf-8" });\n    const address = Address.fromString(addr);\n    \n    const publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });\n    const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;\n\n    const utxos = await Blockfrost.addressUtxos( address )\n        .catch( e => { throw new Error ("unable to find utxos at " + addr) })\n\n    // atleast has 10 ada\n    const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000)!;\n    if (!utxo) {\n        throw new Error("No utxo with more than 10 ada");\n    }\n\n    const nowPosix = Date.now();\n\n    let tx = await txBuilder.buildSync({\n        inputs: [{ utxo: utxo }],\n        collaterals: [ utxo ],\n        outputs: [\n            {\n                address: scriptAddr,\n                value: Value.lovelaces( 10_000_000 ),\n                datum: VestingDatum.VestingDatum({\n                    beneficiary: pBSToData.$( pByteString( pkh.toBuffer() ) ),\n                    deadline: pIntToData.$( nowPosix + 10_000 )\n                })\n            }\n        ],\n        changeAddress: address\n    });\n    \n    await tx.signWith( new PrivateKey(privateKey) );\n\n    const submittedTx = await Blockfrost.submitTx( tx );\n    console.log(submittedTx);\n    \n}\n\nif( process.argv[1].includes("createVesting") )\n{\n    createVesting(blockfrost());\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For the ease of use, let's add a new ",(0,s.jsx)(n.code,{children:"npm script"})," in package.json"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:create": "npm run build:light && node dist/app/createVesting.js"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"now running"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run vesting:create\n"})}),"\n",(0,s.jsx)(n.p,{children:"will generate a new UTxO for the smart contract ready to be spent!"}),"\n",(0,s.jsx)(n.p,{children:"We should also see a similar transaction hash in the console now."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"8b3deb9095898c4d1385269f0af00febaa547e4b4365978d073519caa52f791e\n"})}),"\n",(0,s.jsx)(n.h2,{id:"spend-the-locked-utxo",children:"Spend the locked UTxO"}),"\n",(0,s.jsx)(n.h3,{id:"get-all-you-need",children:"Get all you need"}),"\n",(0,s.jsx)(n.p,{children:"You know the process now:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"read the script"}),"\n",(0,s.jsx)(n.li,{children:"build the script address"}),"\n",(0,s.jsx)(n.li,{children:"read address and keys"}),"\n",(0,s.jsx)(n.li,{children:"query UTxO"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These are the steps needed before we can start to build the transaction and are often very similar."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType } from "@harmoniclabs/plu-ts";\nimport getTxBuilder from "./getTxBuilder";\nimport { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\nimport blockfrost from "./blockfrost";\nimport { readFile } from "fs/promises";\n\nasync function claimVesting(Blockfrost: BlockfrostPluts)\n{\n    const txBuilder = await getTxBuilder(Blockfrost);\n\n    const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });\n    const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)\n    const scriptAddr = new Address(\n        "testnet",\n        new Credential(CredentialType.Script, script.hash)\n    );\n    \n    const privateKeyFile = await readFile("./testnet/payment2.skey", { encoding: "utf-8" });\n    const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );\n\n    const addr = await readFile("./testnet/address2.addr", { encoding: "utf-8" });\n    const address = Address.fromString(addr);\n\n    const publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });\n    const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;\n\n    const utxos = await Blockfrost.addressUtxos( address )\n        .catch( e => { throw new Error ("unable to find utxos at " + addr) });\n    // atleast has 10 ada\n    const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000);\n    if (!utxo) {\n        throw new Error("No utxo with more than 10 ada");\n    }\n\n    /// ...to be continued\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Query the ",(0,s.jsx)(n.code,{children:"scriptUtxos"}),", to specifically use the ",(0,s.jsx)(n.code,{children:"utxo"})," that matches ",(0,s.jsx)(n.code,{children:"publicKeyHash"})," within its datum."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'    const scriptUtxos = await Blockfrost.addressUtxos( scriptAddr )\n        .catch( e => { throw new Error ("unable to find utxos at " + addr) });\n    // matches with the pkh\n    const scriptUtxo = scriptUtxos.find(utxo => {\n        if (utxo.resolved.datum instanceof DataConstr) { \n         const pkhData = utxo.resolved.datum.fields[0]; \n         if (pkhData instanceof DataB) {\n             return pkh.toString() == Buffer.from( pkhData.bytes.toBuffer() ).toString("hex")\n         }\n        }\n        return false; \n     });\n    if (!scriptUtxo) {\n        throw new Error ("No script utxo found for the pkh")\n    }\n'})}),"\n",(0,s.jsxs)(n.admonition,{title:"Use the beneficiary keys!",type:"info",children:[(0,s.jsx)(n.p,{children:"Note that we are reading the keys (both private and public) of the beneficiary, we had set in the previous script, here."}),(0,s.jsx)(n.p,{children:"If we used the other keys the script would fail each time!"})]}),"\n",(0,s.jsx)(n.h3,{id:"build-the-transaciton-1",children:"Build the Transaciton"}),"\n",(0,s.jsx)(n.p,{children:"This time our transaction will be formed as follows"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"one of our utxos"}),"\n",(0,s.jsxs)(n.li,{children:["the UTxO locked at the script address (with corresponding ",(0,s.jsx)(n.code,{children:"Script"})," in order to validate the spending of it)"]}),"\n",(0,s.jsxs)(n.li,{children:["the public key hash as ",(0,s.jsx)(n.code,{children:"requiredSigners"})," element so that it is aviable in ",(0,s.jsx)(n.code,{children:"ctx.tx.signatories"})]}),"\n",(0,s.jsx)(n.li,{children:"our UTxO as collateral input that MUST be present every time a script is included in the transaciton"}),"\n",(0,s.jsxs)(n.li,{children:["the ",(0,s.jsx)(n.code,{children:"invalidBefore"})," field corresponding to the last slot heigth (otherwise the transaciton interval is negative infinite and the contract will fail!)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Of the above, the last one sounds courious... How do we get the last slot of the blockchain?"}),"\n",(0,s.jsx)(n.p,{children:"Blockfrost helps us with that!"}),"\n",(0,s.jsx)(n.p,{children:"we just have to do,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"(await Blockfrost.getChainTip()).slot!\n"})}),"\n",(0,s.jsx)(n.p,{children:"Before building the transaction, we have to ensure the txBuilder genesisInfo is set to its Preprod defaults, by:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"txBuilder.setGenesisInfos( defaultPreprodGenesisInfos )\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now the Transaction can be built as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'let tx = await txBuilder.buildSync({\n        inputs: [\n            { utxo: utxo },\n            {\n                utxo: scriptUtxo,\n                inputScript: {\n                    script: script,\n                    datum: "inline",\n                    redeemer: new DataI( 0 )\n                }\n            }\n        ],\n        requiredSigners: [ pkh ], // required to be included in script context\n        collaterals: [ utxo ],\n        changeAddress: address,\n        invalidBefore: (await Blockfrost.getChainTip()).slot!\n    });\n'})}),"\n",(0,s.jsx)(n.p,{children:"Finally, after we add the Sign and Submit code as done previously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await tx.signWith( privateKey );\n\nconst submittedTx = await Blockfrost.submitTx( tx )\n"})}),"\n",(0,s.jsxs)(n.p,{children:["we can put all together in a ",(0,s.jsx)(n.code,{children:"claimVesting.ts"})," file in the ",(0,s.jsx)(n.code,{children:"app"})," folder:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/claimVesting.ts"',children:'import { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType } from "@harmoniclabs/plu-ts";\nimport getTxBuilder from "./getTxBuilder";\nimport { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\nimport blockfrost from "./blockfrost";\nimport { readFile } from "fs/promises";\n\nasync function claimVesting(Blockfrost: BlockfrostPluts)\n{\n    const txBuilder = await getTxBuilder(Blockfrost);\n\n    const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });\n    const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)\n    const scriptAddr = new Address(\n        "testnet",\n        new Credential(CredentialType.Script, script.hash)\n    );\n    \n    const privateKeyFile = await readFile("./testnet/payment2.skey", { encoding: "utf-8" });\n    const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );\n\n    const addr = await readFile("./testnet/address2.addr", { encoding: "utf-8" });\n    const address = Address.fromString(addr);\n\n    const publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });\n    const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;\n\n    const utxos = await Blockfrost.addressUtxos( address )\n        .catch( e => { throw new Error ("unable to find utxos at " + addr) });\n    // atleast has 10 ada\n    const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000);\n    if (!utxo) {\n        throw new Error("No utxo with more than 10 ada");\n    }\n\n    const scriptUtxos = await Blockfrost.addressUtxos( scriptAddr )\n        .catch( e => { throw new Error ("unable to find utxos at " + addr) });\n    // matches with the pkh\n    const scriptUtxo = scriptUtxos.find(utxo => {\n        if (utxo.resolved.datum instanceof DataConstr) { \n         const pkhData = utxo.resolved.datum.fields[0]; \n         if (pkhData instanceof DataB) {\n             return pkh.toString() == Buffer.from( pkhData.bytes.toBuffer() ).toString("hex")\n         }\n        }\n        return false; \n     });\n    if (!scriptUtxo) {\n        throw new Error ("No script utxo found for the pkh")\n    }\n    \n    txBuilder.setGenesisInfos( defaultPreprodGenesisInfos )\n\n    if (Buffer.from(script.hash.toBuffer()).toString("hex") !== Buffer.from(scriptAddr.paymentCreds.hash.toBuffer()).toString("hex")) {\n        throw new Error("Script hash and script address hash do not match");\n    }\n\n    let tx = await txBuilder.buildSync({\n        inputs: [\n            { utxo: utxo },\n            {\n                utxo: scriptUtxo,\n                inputScript: {\n                    script: script,\n                    datum: "inline",\n                    redeemer: new DataI( 0 )\n                }\n            }\n        ],\n        requiredSigners: [ pkh ], // required to be included in script context\n        collaterals: [ utxo ],\n        changeAddress: address,\n        invalidBefore: (await Blockfrost.getChainTip()).slot!\n    });\n\n    await tx.signWith( privateKey )\n\n    const submittedTx = await Blockfrost.submitTx( tx );\n    console.log(submittedTx);\n    \n}\n\nif( process.argv[1].includes("claimVesting") )\n{\n    claimVesting(blockfrost());\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["After adding a new ",(0,s.jsx)(n.code,{children:"npm script"})," in package.json"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:claim": "npm run build:light && node dist/app/claimVesting.js"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"to try claim the UTxO, we can run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run vesting:claim\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Wait some seconds",type:"caution",children:[(0,s.jsx)(n.p,{children:"If you run the script shortly after you created and locked the UTxO the script will fail!"}),(0,s.jsx)(n.p,{children:"In the previous script, we had set a locking period of 10 seconds."}),(0,s.jsx)(n.p,{children:"So you just have to have a little patience :)"})]}),"\n",(0,s.jsx)(n.p,{children:"If everything goes correctly, the program should terminate without errors. It will definitely console back the transaction hash in the terminal."}),"\n",(0,s.jsx)(n.h2,{id:"bonus-return-the-tada",children:"Bonus: Return the tADA"}),"\n",(0,s.jsx)(n.p,{children:"If you were in public testnet remember to return the tADA to the faucet."}),"\n",(0,s.jsx)(n.p,{children:"For this, you can add the following file and script to automate everything."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/returnFaucet.ts"',children:'import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";\nimport { Address, ITxBuildInput, IUTxO, PrivateKey } from "@harmoniclabs/plu-ts";\nimport { readFile } from "fs/promises";\nimport blockfrost from "./blockfrost";\nimport getTxBuilder from "./getTxBuilder";\n\nasync function returnFaucet(Blockfrost: BlockfrostPluts)\n{\n    const utxos: (ITxBuildInput | IUTxO)[] = [];\n    const pvtKeys: PrivateKey[] = [];\n    \n    for( let i = 1; i <= 2; i++ )\n    {\n        const pvtKeyFile = await readFile(`./testnet/payment${i}.skey`, { encoding: "utf-8" })\n        const pvtKey = PrivateKey.fromCbor( JSON.parse(pvtKeyFile).cborHex );\n        pvtKeys.push( pvtKey );\n\n        const addr = await readFile(`./testnet/address${i}.addr`, { encoding: "utf-8" });\n        const address = Address.fromString(addr);\n\n        const addrUtxos = await Blockfrost.addressUtxos( address )\n        addrUtxos.forEach( utxo => utxos.push({ utxo: utxo }) )\n    }\n\n\n    const txBuilder = await getTxBuilder(Blockfrost);\n\n    let returnTADATx = await txBuilder.buildSync({\n        inputs: utxos as any,\n        // the faucet address\n        changeAddress: "addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3"\n    });\n\n    for(const privateKey of pvtKeys)\n    {\n        await returnTADATx.signWith( privateKey );\n    }\n\n    const submittedTx = await Blockfrost.submitTx( returnTADATx );\n    console.log(submittedTx);\n}\nif( process.argv[1].includes("returnFaucet") )\n{\n    returnFaucet(blockfrost());\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:returnFaucet": "npm run build:light && node dist/app/returnFaucet.js"\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run vesting:returnFaucet\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},87768:(e,n,t)=>{t.d(n,{c:()=>a});t(11504);var s=t(65456);const r={tabItem:"tabItem_Ymn6"};var i=t(17624);function a(e){let{children:n,hidden:t,className:a}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.c)(r.tabItem,a),hidden:t,children:n})}},61268:(e,n,t)=>{t.d(n,{c:()=>v});var s=t(11504),r=t(65456),i=t(53943),a=t(55592),o=t(95288),c=t(10632),l=t(27128),d=t(21148);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:r}}=e;return{value:n,label:t,attributes:s,default:r}}))}(t);return function(e){const n=(0,l.w)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function u(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function x(e){let{queryString:n=!1,groupId:t}=e;const r=(0,a.Uz)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c._M)(i),(0,s.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})}),[i,r])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=p(e),[a,c]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:i}))),[l,h]=x({queryString:t,groupId:r}),[m,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,i]=(0,d.IN)(t);return[r,(0,s.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),g=(()=>{const e=l??m;return u({value:e,tabValues:i})?e:null})();(0,o.c)((()=>{g&&c(g)}),[g]);return{selectedValue:a,selectValue:(0,s.useCallback)((e=>{if(!u({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),f(e)}),[h,f,i]),tabValues:i}}var f=t(93664);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=t(17624);function y(e){let{className:n,block:t,selectedValue:s,selectValue:a,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,i.MV)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),r=o[t].value;r!==s&&(l(n),a(r))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.c)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>c.push(e),onKeyDown:h,onClick:d,...i,className:(0,r.c)("tabs__item",g.tabItem,i?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function w(e){const n=m(e);return(0,j.jsxs)("div",{className:(0,r.c)("tabs-container",g.tabList),children:[(0,j.jsx)(y,{...n,...e}),(0,j.jsx)(b,{...n,...e})]})}function v(e){const n=(0,f.c)();return(0,j.jsx)(w,{...e,children:h(e.children)},String(n))}},4552:(e,n,t)=>{t.d(n,{I:()=>o,M:()=>a});var s=t(11504);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);