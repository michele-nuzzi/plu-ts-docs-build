"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[1784],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||o;return n?i.createElement(h,l(l({ref:t},u),{},{components:n})):i.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[c]="string"==typeof e?e:a,l[1]=r;for(var p=2;p<o;p++)l[p]=n[p];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4976:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const o={sidebar_position:0},l="plet",r={unversionedId:"onchain/Optimizations/plet",id:"onchain/Optimizations/plet",title:"plet",description:"Up until this part of the documentation we wrote plu-ts code that didn't need to re-use values, but in a real case scenario that is quite common.",source:"@site/docs/onchain/Optimizations/plet.mdx",sourceDirName:"onchain/Optimizations",slug:"/onchain/Optimizations/plet",permalink:"/docs/onchain/Optimizations/plet",draft:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts/tree/main/packages/create-docusaurus/templates/shared/docs/onchain/Optimizations/plet.mdx",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"tutorialSidebar",previous:{title:"Optimizations",permalink:"/docs/category/optimizations"},next:{title:"phoist",permalink:"/docs/onchain/Optimizations/phoist"}},s={},p=[{value:"Use <code>plet</code> Luke!",id:"use-plet-luke",level:2},{value:"How does <code>plet</code> work?",id:"how-does-plet-work",level:3},{value:"force execution with <code>plet().in()</code>",id:"force-execution-with-pletin",level:2},{value:"&quot;<code>plet</code>ting&quot; utility terms methods",id:"pletting-utility-terms-methods",level:2},{value:"When is convenient NOT to <code>plet</code>?",id:"when-is-convenient-not-to-plet",level:3}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"plet"},(0,a.kt)("inlineCode",{parentName:"h1"},"plet")),(0,a.kt)("p",null,"Up until this part of the documentation we wrote ",(0,a.kt)("inlineCode",{parentName:"p"},"plu-ts")," code that didn't need to re-use values, but in a real case scenario that is quite common."),(0,a.kt)("p",null,"One might think that storing the result of a ",(0,a.kt)("inlineCode",{parentName:"p"},"plu-ts")," function call can solve the issue, but it actually doesn't."),(0,a.kt)("p",null,"Let's take a look at the following code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const pdoubleFactorial = plam( int, int )\n    ( n => {\n        // DON'T COPY THIS CODE; THIS IS REALLY BAD\n        // bad-practice-start\n        const factorialResult = pfactorial.$( n )\n\n        return factorialResult.add( factorialResult );\n        // bad-practice-end\n    });\n")),(0,a.kt)("p",null,"At first glance, the code above is not doing anything bad, right? "),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"WRONG!")),(0,a.kt)("p",null,"From the ",(0,a.kt)("inlineCode",{parentName:"p"},"plu-ts")," point of view the function above is defined as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const pdoubleFactorial = plam( int, int )\n    ( n => \n        pfactorial.$( n ).add( pfactorial.$( n ) ) \n    );\n")),(0,a.kt)("p",null,"which is calling ",(0,a.kt)("inlineCode",{parentName:"p"},"pfactorial.$( n )")," twice!"),(0,a.kt)("p",null,"The intention of the above code is to store the result of ",(0,a.kt)("inlineCode",{parentName:"p"},"pfactorial.$( n )")," in a variable and then re-use that result, but that is not what is going on here."),(0,a.kt)("h2",{id:"use-plet-luke"},"Use ",(0,a.kt)("inlineCode",{parentName:"h2"},"plet")," Luke!"),(0,a.kt)("p",null,"Fortunately ",(0,a.kt)("inlineCode",{parentName:"p"},"plu-ts")," exposes the ",(0,a.kt)("inlineCode",{parentName:"p"},"plet")," function that does exactly that; we can rewrite the above code as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const pdoubleFactorial = plam( int, int )\n    ( n => {\n        // highlight-solution\n        const factorialResult = plet( pfactorial.$( n ) )\n\n        return factorialResult.add( factorialResult );\n    });\n")),(0,a.kt)("p",null,"This way ",(0,a.kt)("inlineCode",{parentName:"p"},"plu-ts")," can first execute the ",(0,a.kt)("inlineCode",{parentName:"p"},"pfactorial.$( n )")," function call and store the result in the ",(0,a.kt)("inlineCode",{parentName:"p"},"factorialResult")," which was the intended behaviour in the first place."),(0,a.kt)("h3",{id:"how-does-plet-work"},"How does ",(0,a.kt)("inlineCode",{parentName:"h3"},"plet")," work?"),(0,a.kt)("p",null,"When used as in the snippet above the compiler will take a look at how the value you stored in a varible is used and might decide to inline it if it decides that it is more efficient."),(0,a.kt)("p",null,"This will mosto of the time due to the value being used a single time."),(0,a.kt)("p",null,"So even if you are using the result of ",(0,a.kt)("inlineCode",{parentName:"p"},"pfactorial.$( n )")," a single time using ",(0,a.kt)("inlineCode",{parentName:"p"},"plet")," won't store the result in a variable because there's no advantage;"),(0,a.kt)("p",null,"But still if you use it two or more time it will be stored in a variable instead so that it is computed only once-"),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"When in doubt use ",(0,a.kt)("inlineCode",{parentName:"p"},"plet"),";"),(0,a.kt)("p",{parentName:"admonition"},"The compiler is smart enough to unsertand if it should be inlined or stored in a variable")),(0,a.kt)("h2",{id:"force-execution-with-pletin"},"force execution with ",(0,a.kt)("inlineCode",{parentName:"h2"},"plet().in()")),(0,a.kt)("p",null,"You can opt out the compiler taking control using the ",(0,a.kt)("inlineCode",{parentName:"p"},"plet"),"'s ",(0,a.kt)("inlineCode",{parentName:"p"},"in")," method."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"plet( stuff ).in( myVar => {/*...*/})")," construct ",(0,a.kt)("strong",{parentName:"p"},"forces")," the term to be stored in a variable ",(0,a.kt)("strong",{parentName:"p"},"even if used once"),".")),(0,a.kt)("p",null,"There are some cases where this might be the desired behaviour;"),(0,a.kt)("p",null,"as an example using the ",(0,a.kt)("inlineCode",{parentName:"p"},"in")," method makes clear the scope of the variable;"),(0,a.kt)("p",null,"but the most common use case is when you have a single reference in a piece of code that is recursive."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="recursive example"',title:'"recursive','example"':!0},"const fancyDoubleMult = phoist(\n    pfn([ int, int ], int)\n    ((a, b) => {\n\n        // highlight-bad\n        const myVar = plet( pInt(a).add(a) );\n\n        // how you would implement multiplication using only additions\n        return precursive(\n            pfn([\n                lam( int, int ),\n                int\n            ],  int)\n            (( self, n ) => {\n\n                return pif( int ).$( n.ltEq( 0 ) )\n                .then( 0 )\n                .else(\n                    // bad-start\n                    // we only have a single refernce here;\n                    // so this `myVar` might be inlined\n                    myVar.add( self.$( n.sub( 1 ) ) )\n                    // bad-end\n                );\n            })\n        ).$( b )\n    })\n)\n")),(0,a.kt)("p",null,"Even though the compiler will try to do its best, if you want to be sure that you are not re executing some code for each recursive call you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"plet( stuff ).in( myVar => {/*...*/})"),", as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="recursive example"',title:'"recursive','example"':!0},"const fancyDoubleMult = phoist(\n    pfn([ int, int ], int)\n    ((a, b) => {\n\n        // here we force `myVar` to be evaluated\n        // and stored in a variable\n        // highlight-solution\n        return plet( pInt(a).add(a) ).in( myVar => \n            precursive(\n                pfn([\n                    lam( int, int ),\n                    int\n                ],  int)\n                (( self, n ) => {\n\n                    return pif( int ).$( n.ltEq( 0 ) )\n                    .then( 0 )\n                    .else(\n                        // same expression but we know \n                        // we are not re-running `myVar`'s expression\n                        // highlight-solution\n                        myVar.add( self.$( n.sub( 1 ) ) )\n                    );\n                })\n            ).$( b )\n        );\n\n    })\n)\n")),(0,a.kt)("h2",{id:"pletting-utility-terms-methods"},'"',(0,a.kt)("inlineCode",{parentName:"h2"},"plet"),'ting" utility terms methods'),(0,a.kt)("p",null,"When working with ",(0,a.kt)("a",{parentName:"p",href:"../../category/stdlib"},"utility terms")," it's important not to forget that the methods\nare just ",(0,a.kt)("a",{parentName:"p",href:"../Values/Functions/partial_function_app"},"partially applied functions")," so if you plan to use some of the methods more than once is a good idea to ",(0,a.kt)("inlineCode",{parentName:"p"},"plet")," them."),(0,a.kt)("p",null,"As an example, when working with the ",(0,a.kt)("inlineCode",{parentName:"p"},"TermList<PElemsT>")," utility term, intuition might lead you to just reuse the ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," property more than once in various places; but actually, each time you do something like ",(0,a.kt)("inlineCode",{parentName:"p"},"list.length")," (where ",(0,a.kt)("inlineCode",{parentName:"p"},"list")," is a ",(0,a.kt)("inlineCode",{parentName:"p"},"TermList"),"); you are just writing ",(0,a.kt)("inlineCode",{parentName:"p"},"plength.$( list )")," (as in the first case introduced here) which is an ",(0,a.kt)("inlineCode",{parentName:"p"},"O(n)")," operation!"),(0,a.kt)("p",null,"What you really want to do in these cases is something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-next-line\nplet( list.length ).in( myLength => {\n    ...\n})\n")),(0,a.kt)("p",null,"This is also true for terms that do require some arguments."),(0,a.kt)("p",null,"Say you need to access different elements of the ",(0,a.kt)("strong",{parentName:"p"},"same list")," multiple times:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const addFirstTwos = lam( list( int ), int )\n    ( list => \n        padd\n        .$( list.at( 0 ) ) \n        .$( list.at( 1 ) ) \n    );\n")),(0,a.kt)("p",null,"What you are ",(0,a.kt)("strong",{parentName:"p"},"actually")," writing there is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const addFirstTwos = lam( list( int ), int )\n    ( list => \n        padd\n        .$( pindex( int ).$( list ).$( 0 ) ) \n        .$( pindex( int ).$( list ).$( 1 ) ) \n    );\n")),(0,a.kt)("p",null,"If you notice, you are re-writing ",(0,a.kt)("inlineCode",{parentName:"p"},"pindexList( int ).$( list )")," which is a very similar case of calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"pfactorial")," function we saw before twice."),(0,a.kt)("p",null,"Instead is definitely more efficient something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const addFirstTwos = lam( list( int ), int )\n    ( list => \n        // store the function to access the elements of the list\n        // in the `elemAt` variable\n        // highlight-next-line\n        plet( list.atTerm ).in( elemAt =>\n            padd\n            .$( elemAt.$( 0 ) )\n            .$( elemAt.$( 1 ) ) \n        )\n    );\n")),(0,a.kt)("h3",{id:"when-is-convenient-not-to-plet"},"When is convenient NOT to ",(0,a.kt)("inlineCode",{parentName:"h3"},"plet"),"?"),(0,a.kt)("p",null,"You definitely don't want to ",(0,a.kt)("inlineCode",{parentName:"p"},"plet")," everything that is already in a variable; that includes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"arguments of a function"),(0,a.kt)("li",{parentName:"ul"},"terms already ",(0,a.kt)("inlineCode",{parentName:"li"},"plet"),"ted before"),(0,a.kt)("li",{parentName:"ul"},"terms that are already ",(0,a.kt)("em",{parentName:"li"},"hoisted")," (see the ",(0,a.kt)("a",{parentName:"li",href:"./phoist"},"next section"),")"),(0,a.kt)("li",{parentName:"ul"},"terms extracted from a struct using ",(0,a.kt)("a",{parentName:"li",href:"../Control%20Flow/pmatch"},(0,a.kt)("inlineCode",{parentName:"a"},"pmatch"),"/",(0,a.kt)("inlineCode",{parentName:"a"},"extract")),"; ",(0,a.kt)("inlineCode",{parentName:"li"},"extract")," or dot notation, since already wrapped in variables")))}d.isMDXComponent=!0}}]);