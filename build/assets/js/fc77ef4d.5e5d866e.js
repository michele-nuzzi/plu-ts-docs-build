"use strict";(self.webpackChunkplu_ts_docs=self.webpackChunkplu_ts_docs||[]).push([[8538],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(7294),i=n(6010);const r={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r.tabItem,s),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(7462),i=n(7294),r=n(6010),s=n(2466),o=n(6550),l=n(1980),p=n(7392),c=n(12);function d(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}function u(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(r),(0,i.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function k(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=u(e),[s,o]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[l,p]=h({queryString:n,groupId:a}),[d,k]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,c.Nk)(n);return[a,(0,i.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:a}),g=(()=>{const e=l??d;return m({value:e,tabValues:r})?e:null})();(0,i.useLayoutEffect)((()=>{g&&o(g)}),[g]);return{selectedValue:s,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),p(e),k(e)}),[p,k,r]),tabValues:r}}var g=n(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:n,selectedValue:o,selectValue:l,tabValues:p}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),u=e=>{const t=e.currentTarget,n=c.indexOf(t),a=p[n].value;a!==o&&(d(t),l(a))},m=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:s}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:u},s,{className:(0,r.Z)("tabs__item",y.tabItem,s?.className,{"tabs__item--active":o===t})}),n??t)})))}function N(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function b(e){const t=k(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",y.tabList)},i.createElement(f,(0,a.Z)({},e,t)),i.createElement(N,(0,a.Z)({},e,t)))}function w(e){const t=(0,g.Z)();return i.createElement(b,(0,a.Z)({key:String(t)},e))}},8671:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>p,toc:()=>d});var a=n(7462),i=(n(7294),n(3905)),r=n(4866),s=n(5162);const o={sidebar_position:1},l="Vesting",p={unversionedId:"examples/Vesting",id:"examples/Vesting",title:"Vesting",description:"Now that we are a bit more famliar on how to interact properly with a smart contract",source:"@site/docs/examples/Vesting.mdx",sourceDirName:"examples",slug:"/examples/Vesting",permalink:"/docs/examples/Vesting",draft:!1,editUrl:"https://github.com/HarmonicLabs/plu-ts/tree/main/packages/create-docusaurus/templates/shared/docs/examples/Vesting.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Hello plu-ts",permalink:"/docs/examples/Hello World"},next:{title:"Onchain",permalink:"/docs/category/onchain"}},c={},d=[{value:"Project set up",id:"project-set-up",level:2},{value:"Add dependencies",id:"add-dependencies",level:2},{value:"Template overview",id:"template-overview",level:3},{value:"run the template",id:"run-the-template",level:3},{value:"The contract",id:"the-contract",level:2},{value:"<code>VestingDatum</code>",id:"vestingdatum",level:3},{value:"contract signature",id:"contract-signature",level:3},{value:"contract logic",id:"contract-logic",level:3},{value:"<code>signedByBeneficiary</code>",id:"signedbybeneficiary",level:2},{value:"<code>deadlineReached</code>",id:"deadlinereached",level:2},{value:"compiling the contract",id:"compiling-the-contract",level:2},{value:"Interacting with the contract",id:"interacting-with-the-contract",level:2},{value:"setup the <code>cli</code> object",id:"setup-the-cli-object",level:2},{value:"save the script",id:"save-the-script",level:3},{value:"get some keys",id:"get-some-keys",level:3},{value:"create a vesting utxo",id:"create-a-vesting-utxo",level:2},{value:"read the script",id:"read-the-script",level:3},{value:"get your address",id:"get-your-address",level:3},{value:"query the address utxos",id:"query-the-address-utxos",level:3},{value:"build the transaciton",id:"build-the-transaciton",level:3},{value:"sign and submit",id:"sign-and-submit",level:3},{value:"spend the locked utxo",id:"spend-the-locked-utxo",level:2},{value:"get all you need",id:"get-all-you-need",level:3},{value:"build the transaciton",id:"build-the-transaciton-1",level:3},{value:"Bonus: return the tADA",id:"bonus-return-the-tada",level:2}],u={toc:d},m="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"vesting"},"Vesting"),(0,i.kt)("p",null,"Now that we are a bit more famliar on how to interact properly with a smart contract\nlet's do a step forward and see if we can come up with a sligthly more complex contract."),(0,i.kt)("p",null,"The final result can be found at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/HarmonicLabs/vesting-pluts"},(0,i.kt)("inlineCode",{parentName:"a"},"HarmonicLabs/vesting-pluts"))),(0,i.kt)("h2",{id:"project-set-up"},"Project set up"),(0,i.kt)("p",null,"We will once again start from the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/HarmonicLabs/plu-ts-starter"},(0,i.kt)("inlineCode",{parentName:"a"},"plu-ts-starter"))," template:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/HarmonicLabs/plu-ts-starter.git\nmv plu-ts-starter vesting-pluts\ncd vesting-pluts\ngit remote remove origin\n")),(0,i.kt)("p",null,"this gives us a simple project structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"./vesting-pluts\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 contract.ts\n\u2502   \u251c\u2500\u2500 index.ts\n\u2502   \u251c\u2500\u2500 MyDatum\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2514\u2500\u2500 MyRedeemer\n\u2502       \u2514\u2500\u2500 index.ts\n\u2514\u2500\u2500 tsconfig.json\n")),(0,i.kt)("h2",{id:"add-dependencies"},"Add dependencies"),(0,i.kt)("p",null,"Just like the ",(0,i.kt)("a",{parentName:"p",href:"./Hello%20World"},"Hello plu-ts")," example; this project already comes with plu-ts as dependecy;\nall we need to do to then is to run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"npm install\n")),(0,i.kt)("p",null,"to make things easier this time we'll assume to be working on a server environment;\nso we'll use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/HarmonicLabs/cardanocli-pluts"},(0,i.kt)("inlineCode",{parentName:"a"},"cardanocli-pluts"))," in order to submit transacitons."),(0,i.kt)("p",null,"to install it just run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @harmoniclabs/cardanocli-pluts\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"cardano-cli")),(0,i.kt)("p",{parentName:"admonition"},"In order to use ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-cli")," properly you need to have a ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-node")," running"),(0,i.kt)("p",{parentName:"admonition"},"you can install ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-node")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-cli")," either form source or using the precompiled binaries from IOG"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"From source",label:"From source",default:!0,mdxType:"TabItem"},(0,i.kt)("p",{parentName:"admonition"},"1) first lone the repository"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/input-output-hk/cardano-node.git\n")),(0,i.kt)("p",{parentName:"admonition"},"2) make sure to have ",(0,i.kt)("inlineCode",{parentName:"p"},"cabal")," updated"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cabal update\n")),(0,i.kt)("p",{parentName:"admonition"},"3) build the tools"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'git fetch --all --recurse-submodules --tags # Download all branches and tags from the remote repository\ngit checkout $(curl -s https://api.github.com/repos/input-output-hk/cardano-node/releases/latest | jq -r .tag_name) # Switch to the branch of the latest Cardano Node release\necho -e "package cardano-crypto-praos\\n flags: -external-libsodium-vrf" >> cabal.project.local # Append the cabal.project.local file in the current folder to avoid installing the custom libsodium library\ncabal build cardano-node cardano-cli # Compile the cardano-node and cardano-cli packages found in the current directory\n')),(0,i.kt)("p",{parentName:"admonition"},"4) clone the result in a directory where PATH can find them"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'sudo cp $(find ./dist-newstyle/build -type f -name "cardano-node") /usr/bin/cardano-node\nsudo cp $(find ./dist-newstyle/build -type f -name "cardano-cli")  /usr/bin/cardano-cli\n'))),(0,i.kt)(s.Z,{value:"Binaries",label:"Binaries",mdxType:"TabItem"},(0,i.kt)("p",{parentName:"admonition"},"1) Create a temporary path to store the pre-built binaries."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"mkdir ~/vesting_tmp\ncd ~/vesting_tmp\n")),(0,i.kt)("p",{parentName:"admonition"},"2) Download the latest static binaries for Linux. Update below URL with the latest link before continuing."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"wget https://update-cardano-mainnet.iohk.io/cardano-node-releases/cardano-node-1.35.5-linux.tar.gz\n")),(0,i.kt)("p",{parentName:"admonition"},"3) Extract the compressed folders"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"tar -xvf cardano*.gz\n")),(0,i.kt)("p",{parentName:"admonition"},"4) Install the new node and cli binaries."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"sudo mv ~/vesting_tmp/cardano-cli /usr/local/bin/\nsudo mv ~/vesting_tmp/cardano-node /usr/local/bin/\n")),(0,i.kt)("p",{parentName:"admonition"},"5) Clean up temporary path."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cd\nrm -rf ~/tmp2\n"))))),(0,i.kt)("h3",{id:"template-overview"},"Template overview"),(0,i.kt)("p",null,"Before we dive in let's get familiar with the starter template."),(0,i.kt)("p",null,"If we now navigate to ",(0,i.kt)("inlineCode",{parentName:"p"},"src/contract.ts")," we see we have a very simple validator already!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/contract.ts"',title:'"src/contract.ts"'},'import { Address, bool, compile, makeValidator, PaymentCredentials, pBool, pfn, Script, ScriptType, V2 } from "@harmoniclabs/plu-ts";\nimport MyDatum from "./MyDatum";\nimport MyRedeemer from "./MyRedeemer";\n\n\n// highlight-start\nexport const contract = pfn([\n    MyDatum.type,\n    MyRedeemer.type,\n    V2.PScriptContext.type\n],  bool)\n(( datum, redeemer, ctx ) =>\n    // always suceeds\n    pBool( true )\n);\n// highlight-end\n\n\n///////////////////////////////////////////////////////////////////\n// ------------------------------------------------------------- //\n// ------------------------- utilities ------------------------- //\n// ------------------------------------------------------------- //\n///////////////////////////////////////////////////////////////////\n\nexport const untypedValidator = makeValidator( contract );\n\nexport const compiledContract = compile( untypedValidator );\n\nexport const script = new Script(\n    ScriptType.PlutusV2,\n    compiledContract\n);\n\nexport const scriptMainnetAddr = new Address(\n    "mainnet",\n    new PaymentCredentials(\n        "script",\n        script.hash\n    )\n);\n\nexport const scriptTestnetAddr = new Address(\n    "testnet",\n    new PaymentCredentials(\n        "script",\n        script.hash.clone()\n    )\n);\n\nexport default contract;\n')),(0,i.kt)("p",null,"Let's focus only on the contract for now;"),(0,i.kt)("p",null,"this contract expects a ",(0,i.kt)("inlineCode",{parentName:"p"},"MyDatum"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"MyRedeemer")," and finally a ",(0,i.kt)("inlineCode",{parentName:"p"},"PScriptContext")," to validate a transaction."),(0,i.kt)("p",null,"All of the three above are just ",(0,i.kt)("a",{parentName:"p",href:"../onchain/Values/Structs/definition"},(0,i.kt)("inlineCode",{parentName:"a"},"Struct"),"s")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MyDatum")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"MyRedeemer")," are types defined by us respectively in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/MyDatum/index.ts")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"src/MyRedeemer/index.ts")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/MyDatum/index.ts"',title:'"src/MyDatum/index.ts"'},'import { int, pstruct } from "@harmoniclabs/plu-ts";\n\n// modify the Datum as you prefer\nconst MyDatum = pstruct({\n    Num: {\n        number: int\n    },\n    NoDatum: {}\n});\n\nexport default MyDatum;\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/MyRedeemer/index.ts"',title:'"src/MyRedeemer/index.ts"'},'import { pstruct } from "@harmoniclabs/plu-ts";\n\n// modify the Redeemer as you prefer\nconst MyRedeemer = pstruct({\n    Option1: {},\n    Option2: {}\n});\n\nexport default MyRedeemer;\n')),(0,i.kt)("p",null,"whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"PScriptContex")," is a predefined data structure that is passed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-node")," itself that will run our smart contract."),(0,i.kt)("p",null,"finally, the contract is used in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/index.ts")," which is our entry point."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},'import { script } from "./contract";\n\nconsole.log("validator compiled succesfully! \ud83c\udf89\\n");\nconsole.log(\n    JSON.stringify(\n        script.toJson(),\n        undefined,\n        2\n    )\n);\n')),(0,i.kt)("p",null,"the index just imports ",(0,i.kt)("inlineCode",{parentName:"p"},"script")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"src/contract.ts")," adn prints it out in the json form."),(0,i.kt)("p",null,"if we go back to ",(0,i.kt)("inlineCode",{parentName:"p"},"src/contract.ts")," we see that the script is obtained using the following steps:"),(0,i.kt)("p",null,"1) adapting the validator to the standard using ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/utilities/makeValidator"},(0,i.kt)("inlineCode",{parentName:"a"},"makeValidator"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/contract.ts"',title:'"src/contract.ts"'},"/* ... */\n\n// highlight-start\nexport const untypedValidator = makeValidator( contract );\n// highlight-end\n\nexport const compiledContract = compile( untypedValidator );\n\nexport const script = new Script(\n    ScriptType.PlutusV2,\n    compiledContract\n);\n\n/* ... */\n")),(0,i.kt)("p",null,"2) compiling the validator with ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/utilities/compile"},(0,i.kt)("inlineCode",{parentName:"a"},"compile"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/contract.ts"',title:'"src/contract.ts"'},"/* ... */\n\nexport const untypedValidator = makeValidator( contract );\n\n// highlight-start\nexport const compiledContract = compile( untypedValidator );\n// highlight-end\n\nexport const script = new Script(\n    ScriptType.PlutusV2,\n    compiledContract\n);\n\n/* ... */\n")),(0,i.kt)("p",null,"3) wrapping it in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Script")," that can be used offchain"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/contract.ts"',title:'"src/contract.ts"'},"/* ... */\n\nexport const untypedValidator = makeValidator( contract );\n\nexport const compiledContract = compile( untypedValidator );\n\n// highlight-start\nexport const script = new Script(\n    ScriptType.PlutusV2,\n    compiledContract\n);\n// highlight-end\n\n/* ... */\n")),(0,i.kt)("p",null,"that is all we need for now."),(0,i.kt)("h3",{id:"run-the-template"},"run the template"),(0,i.kt)("p",null,"If we did every step of above correctly we should be able to run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run start\n")),(0,i.kt)("p",null,"and the output should look like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'validator compiled succesfully! \ud83c\udf89\n\n{\n  "type": "PlutusScriptV2",\n  "description": "",\n  "cborHex": "56550100002225333573466644494400c0080045261601"\n}\n')),(0,i.kt)("p",null,"Well congratulations \ud83e\udd73!"),(0,i.kt)("p",null,"this is your first compiled smart contract \ud83c\udf89!"),(0,i.kt)("p",null,"But we won't stop here for sure!"),(0,i.kt)("p",null,"Let's personalize this smart contract."),(0,i.kt)("h2",{id:"the-contract"},"The contract"),(0,i.kt)("p",null,"The contract should succeed if the following two conditions are met:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the transaction is signed by the ",(0,i.kt)("inlineCode",{parentName:"li"},"PPubKeyHash")," defined in the UTxO datum;"),(0,i.kt)("li",{parentName:"ul"},"the transaction lower bound is ",(0,i.kt)("inlineCode",{parentName:"li"},"Finite")," and greather than the datum ",(0,i.kt)("inlineCode",{parentName:"li"},"deadline")," field;")),(0,i.kt)("h3",{id:"vestingdatum"},(0,i.kt)("inlineCode",{parentName:"h3"},"VestingDatum")),(0,i.kt)("p",null,"The first thing we notice is that we need a custom datum."),(0,i.kt)("p",null,"so we can rename the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyDatum")," folder to ",(0,i.kt)("inlineCode",{parentName:"p"},"VestingDatum")," and modify ",(0,i.kt)("inlineCode",{parentName:"p"},"src/VestingDatum/index.ts")," as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',title:'"src/VestingDatum/index.ts"'},'import { PPubKeyHash, int, pstruct } from "@harmoniclabs/plu-ts";\n\n// modify the Datum as you prefer\n// highlight-start\nconst VestingDatum = pstruct({\n    VestingDatum: {\n        beneficiary: PPubKeyHash.type,\n        deadline: int // posix time\n    }\n});\n// highlight-end\n\nexport default VestingDatum;\n')),(0,i.kt)("h3",{id:"contract-signature"},"contract signature"),(0,i.kt)("p",null,"Now that we have our datum structure we can use it in the contract definition."),(0,i.kt)("p",null,"Since we are changing the contract signature, we also know that we don't need any particular redeemer; so we can just change it to a simple ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," type;"),(0,i.kt)("p",null,"We can also delete the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyRedeemer")," directory, if we want, since we don't need it anymore."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',title:'"src/VestingDatum/index.ts"'},"/* imports */\n\nexport const contract = pfn([\n    // highlight-next-line\n    VestingDatum.type,\n    // highlight-next-line\n    data,\n    PScriptContext.type\n],  bool)\n(( datum, _redeemer, ctx ) =>\n    // always succeeds\n    pBool( true )\n);\n\n/* other code */\n")),(0,i.kt)("h3",{id:"contract-logic"},"contract logic"),(0,i.kt)("p",null,"As for now our contract succeeds every time we use it."),(0,i.kt)("p",null,"that definitely doesn't meet the specification; so we need to change the body of the funciton too."),(0,i.kt)("p",null,"We know for sure that we need 2 conditions; so we will check them separately using two terms: ",(0,i.kt)("inlineCode",{parentName:"p"},"signedByBeneficiary")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"deadlineReached")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',title:'"src/VestingDatum/index.ts"'},"/* imports */\n\nexport const contract = pfn([\n    VestingDatum.type,\n    data,\n    PScriptContext.type\n],  bool)\n(( datum, _redeemer, ctx ) => {\n    // highlight-start\n\n    // inlined\n    const signedByBeneficiary = pBool( false );\n\n    // inlined\n    const deadlineReached = pBool( false );\n\n    return signedByBeneficiary.and( deadlineReached );\n    // highlight-end\n});\n\n/* other code */\n")),(0,i.kt)("p",null,"We just initialize them to ",(0,i.kt)("inlineCode",{parentName:"p"},"pBool( false )")," so that if we forget them the contract fails."),(0,i.kt)("p",null,"But se can already see the structure of the contract this way: we have two conditions, and we want bot to be true."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"What's ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"// inlined")," for?"),(0,i.kt)("p",{parentName:"admonition"},"As defined above the terms are inlined ",(0,i.kt)("strong",{parentName:"p"},"every time that are used")),(0,i.kt)("p",{parentName:"admonition"},"This is because we are not using ",(0,i.kt)("a",{parentName:"p",href:"../onchain/Optimizations/plet"},(0,i.kt)("inlineCode",{parentName:"a"},"plet"))," to create an actual ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts")," variable;"),(0,i.kt)("p",{parentName:"admonition"},"instead we are just holding a reference to that piece of code."),(0,i.kt)("p",{parentName:"admonition"},"This is not necessarly bad because it helps making the contract more readable (and ",(0,i.kt)("inlineCode",{parentName:"p"},"plet")," would have inlined the term anyway in this paritcular case for efficiency)"),(0,i.kt)("p",{parentName:"admonition"},"but is definitely useful to keep in mind that what we have is ",(0,i.kt)("strong",{parentName:"p"},"always")," inlined with a small comment")),(0,i.kt)("h2",{id:"signedbybeneficiary"},(0,i.kt)("inlineCode",{parentName:"h2"},"signedByBeneficiary")),(0,i.kt)("p",null,"The first condtion for the contract to succeed is:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"the transaction is signed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"PPubKeyHash")," defined in the UTxO datum;")),(0,i.kt)("p",null,"To check that we can use the ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/types/PTxInfo#signatories"},(0,i.kt)("inlineCode",{parentName:"a"},"signatories")," field")," defined in the ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/types/PTxInfo"},(0,i.kt)("inlineCode",{parentName:"a"},"PTxInfo"))," struct."),(0,i.kt)("p",null,"We can access the field from the context using the dot notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ctx.tx.signatories\n")),(0,i.kt)("p",null,"the ",(0,i.kt)("inlineCode",{parentName:"p"},"signatories")," field is a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"PPubKeyHash"),"; so we have access to all the ",(0,i.kt)("a",{parentName:"p",href:"../onchain/stdlib/TermList"},(0,i.kt)("inlineCode",{parentName:"a"},"TermList"))," methods."),(0,i.kt)("p",null,"so we can use the ",(0,i.kt)("a",{parentName:"p",href:"../onchain/stdlib/TermList#some"},(0,i.kt)("inlineCode",{parentName:"a"},"some")," method")," to check that ",(0,i.kt)("strong",{parentName:"p"},"at least one")," element of the list satisfies a given predicate."),(0,i.kt)("p",null,"In our case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ctx.tx.signatories.some( signer => signer.eq( datum.beneficiary ) );\n")),(0,i.kt)("p",null,"Or the equivalent (but sligthly more efficient)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ctx.tx.signatories.some( datum.beneficiary.eqTerm );\n")),(0,i.kt)("p",null,"And that's it!"),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"signedByBeneficiary")," condition becomes the one-liner"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',title:'"src/VestingDatum/index.ts"'},"// inlined\nconst signedByBeneficiary = ctx.tx.signatories.some( datum.beneficiary.eqTerm );\n")),(0,i.kt)("h2",{id:"deadlinereached"},(0,i.kt)("inlineCode",{parentName:"h2"},"deadlineReached")),(0,i.kt)("p",null,"Now we can pass at the second condtion:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"the transaction lower bound is ",(0,i.kt)("inlineCode",{parentName:"p"},"Finite")," and greather than the datum ",(0,i.kt)("inlineCode",{parentName:"p"},"deadline")," field")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"but what do we mean by ",(0,i.kt)("em",{parentName:"mdxAdmonitionTitle"},'"transaciton lower bound"'),"?"),(0,i.kt)("p",{parentName:"admonition"},"That is due to how time is handled on-chain."),(0,i.kt)("p",{parentName:"admonition"},"Handling time on chain is definitely not something simple due to the fact that the underlying system is distributed."),(0,i.kt)("p",{parentName:"admonition"},"That means that we can't really be 100% sure of the exact moment the script is executed."),(0,i.kt)("p",{parentName:"admonition"},"To work around this problem, time is represented on chain with a range in which the transaction is considered valid."),(0,i.kt)("p",{parentName:"admonition"},"If ever the transaction where sent outside of the range it would be rejected by the node before even executing the script!"),(0,i.kt)("p",{parentName:"admonition"},"So we can at least be sure that the script is excuted in the given time range.")),(0,i.kt)("p",null,"We can access the transaction validity time range trough the ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/types/PTxInfo#interval"},(0,i.kt)("inlineCode",{parentName:"a"},"interval")," property")," of the ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/types/PTxInfo"},(0,i.kt)("inlineCode",{parentName:"a"},"PTxInfo"))," struct."),(0,i.kt)("p",null,"this is done once again using the dot notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ctx.tx.interval\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"interval")," type is somewhat complex due to the nested structure; we have"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"two initial properties (",(0,i.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"to"),") representing the lower and upper bound."),(0,i.kt)("li",{parentName:"ul"},"both the properties then have a ",(0,i.kt)("inlineCode",{parentName:"li"},"bound")," property and an ",(0,i.kt)("inlineCode",{parentName:"li"},"inclusive")," property which is a boolean\n(of the two we are only interested in the ",(0,i.kt)("inlineCode",{parentName:"li"},"bound")," one)"),(0,i.kt)("li",{parentName:"ul"},"finally the ",(0,i.kt)("inlineCode",{parentName:"li"},"bound")," has 3 constructors as below")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const PExtended = pstruct({\n    PNegInf: {},\n    PFinite: { _0: int },\n    PPosInf: {}\n});\n")),(0,i.kt)("p",null,"where the ",(0,i.kt)("inlineCode",{parentName:"p"},"PFinite")," one is the one we are interested in."),(0,i.kt)("p",null,"so reaching the ",(0,i.kt)("inlineCode",{parentName:"p"},"bound")," field is the easy part and can be done as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ctx.tx.interval.from.bound\n")),(0,i.kt)("p",null,"but then we have to use ",(0,i.kt)("a",{parentName:"p",href:"../onchain/Control%20Flow/pmatch"},(0,i.kt)("inlineCode",{parentName:"a"},"pmatch"))," to understand what constructor was used;"),(0,i.kt)("p",null,"in particular we are only interested in the ",(0,i.kt)("inlineCode",{parentName:"p"},"PFinite")," one so we'll use the underscore (",(0,i.kt)("inlineCode",{parentName:"p"},"_"),") wildcard to match the other two."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"pmatch( ctx.tx.interval.from.bound )\n.onPFinite(({ _0: lowerInterval }) => ... )\n._( _ => pBool( false ) )\n")),(0,i.kt)("p",null,"and now that we have access to the transaction lower bound we can finally check for the deadline to have been passed"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"datum.deadline.ltEq( lowerInterval ) \n")),(0,i.kt)("p",null,"so the final ",(0,i.kt)("inlineCode",{parentName:"p"},"deadlineReached")," condition becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',title:'"src/VestingDatum/index.ts"'},"// inlined\nconst deadlineReached = \n    pmatch( ctx.tx.interval.from.bound )\n    .onPFinite(({ _0: lowerInterval }) =>\n        datum.deadline.ltEq( lowerInterval ) \n    )\n    ._( _ => pBool( false ) )\n")),(0,i.kt)("h2",{id:"compiling-the-contract"},"compiling the contract"),(0,i.kt)("p",null,"So now the our smart contract should look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',title:'"src/VestingDatum/index.ts"'},"export const contract = pfn([\n    VestingDatum.type,\n    data,\n    PScriptContext.type\n],  bool)\n(( datum, _redeemer, ctx ) => {\n\n    // inlined\n    const signedByBeneficiary = ctx.tx.signatories.some( datum.beneficiary.eqTerm );\n\n    // inlined\n    const deadlineReached = \n        pmatch( ctx.tx.interval.from.bound )\n        .onPFinite(({ _0: lowerInterval }) =>\n                datum.deadline.ltEq( lowerInterval ) \n        )\n        ._( _ => pBool( false ) )\n\n    return signedByBeneficiary.and( deadlineReached );\n});\n")),(0,i.kt)("p",null,"as we saw in the ",(0,i.kt)("a",{parentName:"p",href:"./Hello%20World"},"Hello plu-ts example project")," we can compile the contract\nby first passing the term to ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/utilities/makeValidator"},(0,i.kt)("inlineCode",{parentName:"a"},"makeValidator")),"\nand then pass the result to the ",(0,i.kt)("a",{parentName:"p",href:"../onchain/API/utilities/compile"},(0,i.kt)("inlineCode",{parentName:"a"},"compile"))," function."),(0,i.kt)("p",null,"We finally pass the compiled Contract to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Script")," constructor so that we can use it properly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/VestingDatum/index.ts"',title:'"src/VestingDatum/index.ts"'},"/* contract definition above */\n\nexport const untypedValidator = makeValidator( contract );\n\nexport const compiledContract = compile( untypedValidator );\n\nexport const script = new Script(\n    ScriptType.PlutusV2,\n    compiledContract\n);\n\n/* some other code */\n")),(0,i.kt)("p",null,"so now running the project using"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run start\n")),(0,i.kt)("p",null,"we should see something like this"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'validator compiled succesfully! \ud83c\udf89\n\n{\n  "type": "PlutusScriptV2",\n  "description": "",\n  "cborHex": "5901445901410100003232323232222533357346664446644a666ae680080045281991980510a502223322533357340042944004c0100084c00c004dc79bae357426010006664664601246ae80c0080040052f588eb8dd6191aba1357446ae88d5d11aba2357446ae88d5d11aba200130083574260100022646666444464664a666ae68c005200010031533357346002900108020a999ab9a300148010401458dc39aab9d00135573c0026ea8010d5d098049aba1300932357426ae88d5d11aba2357446ae88d5d11aba20013009357426012004002466e24dd6991aba135744002601400a6eb4d5d0800800925000300200114985888cc01084008888cc014008c00c0048d55cf1baa0013002222232333006300400130030010023300400300222253335573e0020062660046ae84004d5d10009191801119801001000918011198010010009"\n}\n')),(0,i.kt)("h2",{id:"interacting-with-the-contract"},"Interacting with the contract"),(0,i.kt)("p",null,"We will use the native ",(0,i.kt)("inlineCode",{parentName:"p"},"npm")," script functionality to define some scripts to interact arbitrarly with our new contract."),(0,i.kt)("p",null,"We can define a new script by adding an entry in the ",(0,i.kt)("inlineCode",{parentName:"p"},"scripts")," field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"package.json")," file that you find in the root of the project."),(0,i.kt)("p",null,"right now you should see something like this"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'"scripts": {\n    "build": "tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json",\n    "start": "npm run build && node dist/index.js"\n},\n')),(0,i.kt)("p",null,"we can add our own scripts by specifying the script name as key and the command to execute as value."),(0,i.kt)("p",null,"as an example; say we want a better name for the ",(0,i.kt)("inlineCode",{parentName:"p"},'"start"')," script.; we could do something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'"scripts": {\n    "build": "tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json",\n    "start": "npm run build && node dist/index.js",\n    // highlight-next-line\n    "vesting:compile": "npm run start"\n},\n')),(0,i.kt)("p",null,"and now running"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run vesting:compile\n")),(0,i.kt)("p",null,"is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"npm run start"),"."),(0,i.kt)("p",null,"to keep the project clean we'll create a new directory under ",(0,i.kt)("inlineCode",{parentName:"p"},"src")," called ",(0,i.kt)("inlineCode",{parentName:"p"},"app")," where all our scripts will be."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"./vesting-pluts\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 app\n")),(0,i.kt)("h2",{id:"setup-the-cli-object"},"setup the ",(0,i.kt)("inlineCode",{parentName:"h2"},"cli")," object"),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"app")," folder create a new directory called ",(0,i.kt)("inlineCode",{parentName:"p"},"utils")," and a new file called ",(0,i.kt)("inlineCode",{parentName:"p"},"cli.ts"),"."),(0,i.kt)("p",null,"here we'll import the ",(0,i.kt)("inlineCode",{parentName:"p"},"CardanoCliPluts")," class from the ",(0,i.kt)("inlineCode",{parentName:"p"},"@harmoniclabs/cardanocli-pluts")," package we installed at the beginning;\nconstruct an instance and export it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/app/utils/cli.ts"',title:'"src/app/utils/cli.ts"'},'import { CardanoCliPluts } from "@harmoniclabs/cardanocli-pluts";\n\nexport const cli = new CardanoCliPluts({\n    network: "testnet 1",\n    // socketPath: undefined // defaults to process.env.CARDANO_NODE_SOCKET_PATH\n});\n')),(0,i.kt)("p",null,"this cli will work for the ",(0,i.kt)("inlineCode",{parentName:"p"},"preprod")," testnet."),(0,i.kt)("p",null,"If you are working on a private testnet then you can also use the ",(0,i.kt)("inlineCode",{parentName:"p"},"dotenv")," package and specify a custom ",(0,i.kt)("inlineCode",{parentName:"p"},"socketPath")," for the private testnet node."),(0,i.kt)("p",null,"you can install ",(0,i.kt)("inlineCode",{parentName:"p"},"dotenv")," by running"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm install dotenv\n")),(0,i.kt)("p",null,"In a set up like the one in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/woofpool/cardano-private-testnet-setup"},(0,i.kt)("inlineCode",{parentName:"a"},"woofpool/cardano-private-testnet-setup"))," the code becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/app/utils/cli.ts"',title:'"src/app/utils/cli.ts"'},'import { CardanoCliPluts } from "@harmoniclabs/cardanocli-pluts";\nimport { config } from "dotenv";\n\nconfig();\n\nexport const cli = new CardanoCliPluts({\n    network: "testnet 42",\n    socketPath: (process.env.PRIVATE_TESTNET_PATH ?? ".") + "/node-spo1/node.sock"\n});\n')),(0,i.kt)("h3",{id:"save-the-script"},"save the script"),(0,i.kt)("p",null,"Now that we have access to the cli we can easly work with the offchain part of plu-ts and the cardano-node."),(0,i.kt)("p",null,"let's start by saving the compiled script to a file when we compile it."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/index.ts")," file add the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},'// highlight-start\nimport { existsSync } from "fs";\nimport { mkdir } from "fs/promises";\n// highlight-end\n\n/* old code */\n\n// highlight-start\nasync function main() \n{\n    if( !existsSync("./testnet") )\n    {\n        await mkdir("./testnet");\n    }\n    cli.utils.writeScript( script, "./testnet/vesting.plutus.json")\n}\nmain();\n// highlight-end\n')),(0,i.kt)("p",null,"now running "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run vesting:compile\n")),(0,i.kt)("p",null,"should still print the old result; but it will also create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"testnet")," directory with file called ",(0,i.kt)("inlineCode",{parentName:"p"},"vesting.plutus.json")," in it."),(0,i.kt)("h3",{id:"get-some-keys"},"get some keys"),(0,i.kt)("p",null,"depending if you are working in private or public testnet\nthere are 2 way to get your keys and start creating transactions:"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"public testnet",label:"public testnet",default:!0,mdxType:"TabItem"},(0,i.kt)("p",null,"if you are working in the public testnet then you can generate a new pair of keys using"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"cli.address.keyGen()\n")),(0,i.kt)("p",null,"which executes the ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-cli")," command"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cardano-cli address key-gen --testnet-magic 1\n")),(0,i.kt)("p",null,"so to generate 2 pairs of keys we could create a file callde ",(0,i.kt)("inlineCode",{parentName:"p"},"genKeys.ts")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"app")," folder that looks like this"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { existsSync } from "fs";\nimport { cli } from "./utils/cli";\nimport { Address, PaymentCredentials } from "@harmoniclabs/plu-ts";\nimport { config } from "dotenv";\nimport { mkdir } from "fs/promises";\n\nconfig();\n\nasync function genKeys()\n{\n    const nKeys = 2;\n\n    const promises: Promise<any>[] = [];\n\n    if( !existsSync("./testnet") )\n    {\n        await mkdir("./testnet");\n    }\n    \n    for( let i = 1; i <= nKeys; i++ )\n    {\n        const { privateKey, publicKey } = await cli.address.keyGen();\n        const addr = new Address(\n            "testnet",\n            PaymentCredentials.pubKey( publicKey.hash )\n        );\n        \n        promises.push(\n            cli.utils.writeAddress( addr, `./testnet/address${i}.addr` ),\n            cli.utils.writePublicKey( publicKey, `./testnet/payment${i}.vkey` ),\n            cli.utils.writePrivateKey( privateKey, `./testnet/payment${i}.skey` )\n        );\n    }\n\n    // wait for all files to be copied\n    await Promise.all( promises );\n}\ngenKeys();\n')),(0,i.kt)("p",null,"then we can add a new ",(0,i.kt)("inlineCode",{parentName:"p"},"npm")," script called ",(0,i.kt)("inlineCode",{parentName:"p"},"vesting:genKeys")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:genKeys": "npm run build:light && node dist/app/genKeys.js"\n}\n')),(0,i.kt)("p",null,"so that running"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run vesting:genKeys\n")),(0,i.kt)("p",null,"should give us 2 pairs of keys and 2 addresses under the ",(0,i.kt)("inlineCode",{parentName:"p"},"testnet")," folder."),(0,i.kt)("admonition",{title:"get some founds",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"remeber to found one of the addresses."),(0,i.kt)("p",{parentName:"admonition"},"you can get some founds as described in the ",(0,i.kt)("a",{parentName:"p",href:"./Hello%20World#get-some-founds"},"Hello World example")))),(0,i.kt)(s.Z,{value:"private testnet",label:"private testnet",mdxType:"TabItem"},(0,i.kt)("p",null,"if you are working in the private testnet then you probably want to use some keys you already have."),(0,i.kt)("p",null,"then maybe you can copy those keys in the ",(0,i.kt)("inlineCode",{parentName:"p"},"testnet")," folder we have here."),(0,i.kt)("p",null,"to do so we can set up a new ",(0,i.kt)("inlineCode",{parentName:"p"},"setup.ts")," script under the ",(0,i.kt)("inlineCode",{parentName:"p"},"app")," folder:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { existsSync } from "fs";\nimport { config } from "dotenv";\nimport { copyFile, mkdir } from "fs/promises";\n\nconfig();\n\nasync function setup()\n{\n    const privateTestnet = process.env.PRIVATE_TESTNET_PATH ?? ".";\n\n    const nKeys = 3;\n\n    const promises: Promise<any>[] = [];\n    if( !existsSync("./testnet") )\n    {\n        await mkdir("./testnet");\n    }\n    \n    for( let i = 1; i <= nKeys; i++ )\n    {\n        promises.push(\n            copyFile(`${privateTestnet}/addresses/payment${i}.addr`, `./testnet/address${i}.addr`),\n            copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.vkey`, `./testnet/payment${i}.vkey`),\n            copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.skey`, `./testnet/payment${i}.skey`)\n        );\n    }\n\n    // wait for all files to be copied\n    await Promise.all( promises );\n}\nsetup();\n')),(0,i.kt)("p",null,"and then include a new ",(0,i.kt)("inlineCode",{parentName:"p"},"npm script")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"package.json")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:setup": "npm run build:light && node dist/app/setup.js"\n}\n')),(0,i.kt)("p",null,"so that you can now run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run vesting:setup\n")),(0,i.kt)("p",null,"to have your keys and addresses copied in the ",(0,i.kt)("inlineCode",{parentName:"p"},"testnet")," folder"))),(0,i.kt)("h2",{id:"create-a-vesting-utxo"},"create a vesting utxo"),(0,i.kt)("p",null,"Now we can finally start playing around with the vesting contract."),(0,i.kt)("h3",{id:"read-the-script"},"read the script"),(0,i.kt)("p",null,"Since we already have our file compiled and saved is probably a good idea to read the compiled result instead of re compiling the contract each time we run teh script."),(0,i.kt)("p",null,"to do so we can once again use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cli.utils")," to read a saved ",(0,i.kt)("inlineCode",{parentName:"p"},"Script"),"; we just need to specify the path."),(0,i.kt)("p",null,"so in our case we can write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const script = cli.utils.readScript("./testnet/vesting.plutus.json");\n')),(0,i.kt)("p",null,"from here we can generate the script address using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Address")," class (from the offchain of ",(0,i.kt)("inlineCode",{parentName:"p"},"plu-ts"),") and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Script")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"PaymentCredentials"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const scriptAddr = new Address(\n    "testnet",\n    PaymentCredentials.script( script.hash )\n);\n')),(0,i.kt)("h3",{id:"get-your-address"},"get your address"),(0,i.kt)("p",null,"Then to build and send our transaction we are just missing the sender key and address and the beneficiary public key."),(0,i.kt)("p",null,"using the ",(0,i.kt)("inlineCode",{parentName:"p"},"cli.utils")," once again we can get them very easly"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const privateKey = cli.utils.readPrivateKey("./testnet/payment1.skey");\nconst addr = cli.utils.readAddress("./testnet/address1.addr");\nconst beneficiary = cli.utils.readPublicKey("./testnet/payment2.vkey");\n')),(0,i.kt)("h3",{id:"query-the-address-utxos"},"query the address utxos"),(0,i.kt)("p",null,"before we really start building our transaction we need some utxos to use as input;\nwe can get them always using the ",(0,i.kt)("inlineCode",{parentName:"p"},"cli")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const [ utxo ] = await cli.query.utxo({ address: addr });\n")),(0,i.kt)("h3",{id:"build-the-transaciton"},"build the transaciton"),(0,i.kt)("p",null,"then our transaction will be constructed as follow:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"our UTxO as input"),(0,i.kt)("li",{parentName:"ul"},"an output to the contract with an attached ",(0,i.kt)("inlineCode",{parentName:"li"},"VestingDatum")),(0,i.kt)("li",{parentName:"ul"},"the change going back to the address")),(0,i.kt)("p",null,"which translates to the following code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let tx = await cli.transaction.build({\n    inputs: [{ utxo: utxo }],\n    outputs: [\n        {\n            address: scriptAddr,\n            value: Value.lovelaces( 10_000_000 ),\n            // highlight-start\n            datum: VestingDatum.VestingDatum({\n                beneficiary: pBSToData.$( pByteString( beneficiary.hash.toBuffer() ) ),\n                deadline: pIntToData.$( nowPosix + 10_000 )\n            })\n            // highlight-end\n        }\n    ],\n    changeAddress: addr\n});\n")),(0,i.kt)("admonition",{title:"have you noticed?",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"the ",(0,i.kt)("inlineCode",{parentName:"p"},"datum")," attached to the output is generated using on-chain code!"),(0,i.kt)("p",{parentName:"admonition"},"this is done thanks to plu-ts being able to evaluate on chain code and use the result as ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")),(0,i.kt)("p",{parentName:"admonition"},"this way we can use the on chain types to describe the plutus data offchain; whithout the need to use low level ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," elements! ")),(0,i.kt)("h3",{id:"sign-and-submit"},"sign and submit"),(0,i.kt)("p",null,"so now that we have our transaciton all we need is just to sign and submit it."),(0,i.kt)("p",null,"And guess what? this is also extremly easy thanks to ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-cli")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"tx = await cli.transaction.sign({ tx, privateKey });\n\nawait cli.transaction.submit({ tx: tx });\n")),(0,i.kt)("p",null,"so all we need to do now is to put all together in a file called ",(0,i.kt)("inlineCode",{parentName:"p"},"createVesting.ts")," under the ",(0,i.kt)("inlineCode",{parentName:"p"},"app")," folder"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/app/createVesting.ts"',title:'"src/app/createVesting.ts"'},'import { Address, PaymentCredentials, Value, pBSToData, pByteString, pIntToData } from "@harmoniclabs/plu-ts";\nimport { cli } from "./utils/cli";\nimport VestingDatum from "../VestingDatum";\n\nasync function createVesting()\n{\n    const script = cli.utils.readScript("./testnet/vesting.plutus.json");\n\n    const scriptAddr = new Address(\n        "testnet",\n        PaymentCredentials.script( script.hash )\n    );\n    \n    const privateKey = cli.utils.readPrivateKey("./testnet/payment1.skey");\n    const addr = cli.utils.readAddress("./testnet/address1.addr");\n    const beneficiary = cli.utils.readPublicKey("./testnet/payment2.vkey");\n\n    const utxos = await cli.query.utxo({ address: addr });\n\n    if( utxos.length === 0 )\n    {\n        throw new Error(\n            "no utxos found at address " + addr.toString()\n        );\n    }\n\n    const utxo = utxos[0];\n\n    const nowPosix = Date.now();\n\n    let tx = await cli.transaction.build({\n        inputs: [{ utxo: utxo }],\n        collaterals: [ utxo ],\n        outputs: [\n            {\n                address: scriptAddr,\n                value: Value.lovelaces( 10_000_000 ),\n                datum: VestingDatum.VestingDatum({\n                    beneficiary: pBSToData.$( pByteString( beneficiary.hash.toBuffer() ) ),\n                    deadline: pIntToData.$( nowPosix + 10_000 )\n                })\n            }\n        ],\n        changeAddress: addr\n    });\n\n    tx = await cli.transaction.sign({ tx, privateKey });\n\n    await cli.transaction.submit({ tx: tx });\n}\n\nif( process.argv[1].includes("createVesting") )\n{\n    createVesting();\n}\n')),(0,i.kt)("p",null,"and for the ease of use we'll add a new ",(0,i.kt)("inlineCode",{parentName:"p"},"npm script")," in package.json"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:create": "npm run build:light && node dist/app/createVesting.js"\n}\n')),(0,i.kt)("p",null,"now running"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run vesting:create\n")),(0,i.kt)("p",null,"will generate a new utxo for the smart contract ready to be spent!"),(0,i.kt)("h2",{id:"spend-the-locked-utxo"},"spend the locked utxo"),(0,i.kt)("h3",{id:"get-all-you-need"},"get all you need"),(0,i.kt)("p",null,"You know the process now:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"read the script"),(0,i.kt)("li",{parentName:"ul"},"build the script address"),(0,i.kt)("li",{parentName:"ul"},"read address and keys"),(0,i.kt)("li",{parentName:"ul"},"query utxo")),(0,i.kt)("p",null,"these are the steps needed before we can start to build the transaction and are often very similar."),(0,i.kt)("p",null,"so here there's the code. You should be able to understand what it does whithout problems"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { Address, DataI, PaymentCredentials } from "@harmoniclabs/plu-ts";\nimport { cli } from "./utils/cli";\n\nasync function claimVesting()\n{\n    const script = cli.utils.readScript("./testnet/vesting.plutus.json");\n\n    const scriptAddr = new Address(\n        "testnet",\n        PaymentCredentials.script( script.hash )\n    );\n    \n    const privateKey = cli.utils.readPrivateKey("./testnet/payment2.skey");\n    const addr = cli.utils.readAddress("./testnet/address2.addr");\n\n    const utxos = await cli.query.utxo({ address: addr });\n    const scriptUtxos = await cli.query.utxo({ address: scriptAddr });\n\n    if( utxos.length === 0 || scriptUtxos.length === 0 )\n    {\n        throw new Error(\n            "no utxos found at address " + addr.toString()\n        );\n    }\n\n    const utxo = utxos[0];\n\n    const pkh = cli.utils.readPublicKey("./testnet/payment2.vkey").hash;\n}\n')),(0,i.kt)("admonition",{title:"use the beneficiary keys!",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Note that we are reading the keys of the beneficiary we setted in the previous script this time"),(0,i.kt)("p",{parentName:"admonition"},"If we used the other keys teh script would fail each time!")),(0,i.kt)("h3",{id:"build-the-transaciton-1"},"build the transaciton"),(0,i.kt)("p",null,"this time our transaction will be formed as follows"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"one of our utxos"),(0,i.kt)("li",{parentName:"ul"},"the utxo locked at the script address (with corresponding ",(0,i.kt)("inlineCode",{parentName:"li"},"Script")," in order to validate the spending of it)"),(0,i.kt)("li",{parentName:"ul"},"the public key hash as ",(0,i.kt)("inlineCode",{parentName:"li"},"requiredSigners")," element so that it is aviable in ",(0,i.kt)("inlineCode",{parentName:"li"},"ctx.tx.signatories")),(0,i.kt)("li",{parentName:"ul"},"our utxo as collateral input that MUST be present every time a script is included in the transaciton"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"invalidBefore")," field corresponding to the last slot heigth (otherwise the transaciton interval is negative infinite and the contract will fail!)")),(0,i.kt)("p",null,"of the above the last one sounds courious... How do we get the last slot of the blockchain?"),(0,i.kt)("p",null,"once again the cli does that for us too!"),(0,i.kt)("p",null,"we just have to call"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"cli.query.tipSync()\n")),(0,i.kt)("p",null,"and then access the ",(0,i.kt)("inlineCode",{parentName:"p"},"tip")," field."),(0,i.kt)("p",null,"so the transaction can be built as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'let tx = await cli.transaction.build({\n    inputs: [\n        { utxo: utxo },\n        {\n            utxo: scriptUtxos[0],\n            inputScript: {\n                script: script,\n                datum: "inline",\n                redeemer: new DataI( 0 )\n            }\n        }\n    ],\n    requiredSigners: [ pkh ], // required to be included in script context\n    collaterals: [ utxo ],\n    changeAddress: addr,\n    invalidBefore: cli.query.tipSync().slot\n});\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"the ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"TxBuilder")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"cardano-cli")," will only work on a server environment"),(0,i.kt)("p",{parentName:"admonition"},"if you are working in a web environment plu-ts exports a ",(0,i.kt)("inlineCode",{parentName:"p"},"TxBuilder")," class that is extremly similar to how the ",(0,i.kt)("inlineCode",{parentName:"p"},"cardano-cli")," works."),(0,i.kt)("p",{parentName:"admonition"},"to build a ",(0,i.kt)("inlineCode",{parentName:"p"},"TxBuilder")," instance all you need are the protocol parameters; that as an example you can query easly using the cli"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const txBuilder = new TxBuilder(\n    "testnet",\n    cli.query.protocolParamsSync()\n);\n')),(0,i.kt)("p",{parentName:"admonition"},"and then you just need to replace ",(0,i.kt)("inlineCode",{parentName:"p"},"cli.transaciton.build")," with 'txBuilder.build'; as in the example"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'let tx = await txBuilder.build({\n    inputs: [\n        { utxo: utxo },\n        {\n            utxo: scriptUtxos[0],\n            inputScript: {\n                script: script,\n                datum: "inline",\n                redeemer: new DataI( 0 )\n            }\n        }\n    ],\n    requiredSigners: [ pkh ], // required to be included in script context\n    collaterals: [ utxo ],\n    changeAddress: addr,\n    invalidBefore: cli.query.tipSync().slot\n});\n'))),(0,i.kt)("p",null,"and finally; after we add teh sing and submit code as done previously;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"tx = await cli.transaction.sign({ tx, privateKey });\n\nawait cli.transaction.submit({ tx: tx });\n")),(0,i.kt)("p",null,"we can put all together in a ",(0,i.kt)("inlineCode",{parentName:"p"},"claimVesting.ts")," file in the ",(0,i.kt)("inlineCode",{parentName:"p"},"app")," folder:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/app/claimVesting.ts"',title:'"src/app/claimVesting.ts"'},'import { Address, DataI, PaymentCredentials } from "@harmoniclabs/plu-ts";\nimport { cli } from "./utils/cli";\n\nasync function claimVesting()\n{\n    const script = cli.utils.readScript("./testnet/vesting.plutus.json");\n\n    const scriptAddr = new Address(\n        "testnet",\n        PaymentCredentials.script( script.hash )\n    );\n    \n    const privateKey = cli.utils.readPrivateKey("./testnet/payment2.skey");\n    const addr = cli.utils.readAddress("./testnet/address2.addr");\n\n    const utxos = await cli.query.utxo({ address: addr });\n    const scriptUtxos = await cli.query.utxo({ address: scriptAddr });\n\n    if( utxos.length === 0 || scriptUtxos.length === 0 )\n    {\n        throw new Error(\n            "no utxos found at address " + addr.toString()\n        );\n    }\n\n    const utxo = utxos[0];\n\n    const pkh = cli.utils.readPublicKey("./testnet/payment2.vkey").hash;\n\n    let tx = await cli.transaction.build({\n        inputs: [\n            { utxo: utxo },\n            {\n                utxo: scriptUtxos[0],\n                inputScript: {\n                    script: script,\n                    datum: "inline",\n                    redeemer: new DataI( 0 )\n                }\n            }\n        ],\n        requiredSigners: [ pkh ], // required to be included in script context\n        collaterals: [ utxo ],\n        changeAddress: addr,\n        invalidBefore: cli.query.tipSync().slot\n    });\n\n    tx = await cli.transaction.sign({ tx, privateKey });\n\n    await cli.transaction.submit({ tx: tx });\n}\n\nif( process.argv[1].includes("claimVesting") )\n{\n    claimVesting();\n}\n')),(0,i.kt)("p",null,"then after adding a new ",(0,i.kt)("inlineCode",{parentName:"p"},"npm script")," in package.json"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:claim": "npm run build:light && node dist/app/claimVesting.js"\n}\n')),(0,i.kt)("p",null,"To try claim the utxo we can run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run vesting:claim\n")),(0,i.kt)("admonition",{title:"wait some seconds",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"if you run the script shortly after you created and locked the utxo the script will fail!"),(0,i.kt)("p",{parentName:"admonition"},"in the previous script we setted a locking period of 10 seconds"),(0,i.kt)("p",{parentName:"admonition"},"so you just have to have a little patience :)")),(0,i.kt)("p",null,"if everything goes correctly the program should terminate whithout errors."),(0,i.kt)("h2",{id:"bonus-return-the-tada"},"Bonus: return the tADA"),(0,i.kt)("p",null,"if you where in public testnet remeber to return the tADA to the faucet."),(0,i.kt)("p",null,"here; you can add the following file and script to automate everything"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'"scripts": {\n    // ...\n    // highlight-next-line\n    "vesting:returnFaucet": "npm run build:light && node dist/app/returnFaucet.js"\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run vesting:returnFaucet\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/app/returnFaucet.ts"',title:'"src/app/returnFaucet.ts"'},'import { PrivateKey, TxOutRef } from "@harmoniclabs/plu-ts";\nimport { cli } from "./utils/cli";\n\nasync function returnFaucet()\n{\n    const utxos: { utxo: TxOutRef }[] = [];\n    const prvtKeys: PrivateKey[] = [];\n    \n    for( let i = 1; i <= 2; i++ )\n    {\n        prvtKeys.push( cli.utils.readPrivateKey(`./testnet/payment${i}.skey`) );\n        const addr = cli.utils.readAddress(`./testnet/address${i}.addr`);\n        \n        utxos.push(\n            ...(await cli.query.utxo({ address: addr }))\n            .map( ({ utxoRef }) => ({ utxo: utxoRef } ))\n        );\n    }\n\n    let returnTADA = await cli.transaction.build({\n        inputs: utxos as any,\n        // the faucet address\n        changeAddress: "addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3"\n    });\n\n    for(const privateKey of prvtKeys)\n    {\n        returnTADA = await cli.transaction.sign({ tx: returnTADA, privateKey });\n    }\n\n    await cli.transaction.submit({ tx: returnTADA });\n}\nif( process.argv[1].includes("returnFaucet") )\n{\n    returnFaucet();\n}\n')))}h.isMDXComponent=!0}}]);